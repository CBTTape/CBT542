/* REXX - CSICODE : Minimum clean CSI utilisation code - old version  */
/**********************************************************************/
/* CSICODE : Uses Catalog Search Interface (CSI)                      */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 12/01/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 15/01/2002 - Alastair Gray - Added DSCRDT2 field         */
/* 1.0.2   - 22/01/2002 - Alastair Gray - Re-ordered fields           */
/* 1.0.3   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.0.4   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.0.5   - 08/08/2002 - Alastair Gray - Updated device list         */
/* 1.0.6   - 20/09/2002 - Alastair Gray - Updates for CSICODEV        */
/* 1.0.7   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.0.8   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.0.9   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This provides a clean base for further CSI development work.    */
/*                                                                    */
/* 2. This processes all catalogs and lists all entries.              */
/*                                                                    */
/* 3. The output is written to members of a PDS allocated to REPORT   */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say '**(Error-1)* No TSO environment and no OMVS environment.'
  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat = ' '                            /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = ' '                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
member = 'REPORT'                    /* processing ALIAS              */
x = CSI(cat,flt,typ,ct1)             /* Call CSI procedure            */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
csiresrv = Substr(' ',1,1)           /* clear reserve character       */
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000D'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld10 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld11 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csiresrv
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say '**(Error-1)* CSI processing.'
   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* Work Area defined  = 'csiusrln
   Say '**(Error-2)* Work Area used     = 'csiusdln
   Say '**(Error-3)* Work Area required = 'csireqln
   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */
    If (csienter = '1') Then         /* entry error                   */
     Do
      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
      plus = 50                      /* length for error entry        */
     End
    Else                             /*                               */
     Do                              /*                               */
      Call ENTRY                     /* Execute entry processing      */
      plus = 46 + csitotln           /* length for normal entry       */
     End                             /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
e_off = off + 46                     /* get offset to entries         */
o_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */
l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */
e_pos = 6                            /* set offset of second field    */
Do flds = 2 to C2d(csinumen)         /* loop through other fields     */
 prv = flds - 1                      /* set 'previous' value          */
 o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */
 l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */
 e_pos = e_pos + 2                   /*                               */
End                                  /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
cattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */
volser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */
fileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */
vsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
  Say '**(Error-2)* Entry type ='entype
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_TYPE     - Process TYPE     field                              */
/**********************************************************************/
FLD_TYPE:                            /* TYPE     field processing   ##*/
type_list = ''                       /* loop through type             */
Do z = 1 to Length(type)             /* loop through type             */
 astype = Substr(type,z,1)           /* decode type flag              */
 Select                              /* decode type flag              */
  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */
  When (astype = 'D') Then astype = 'DATA'     /*                     */
  When (astype = 'I') Then astype = 'INDEX'    /*                     */
  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */
  When (astype = 'H') Then astype = 'GDS'      /*                     */
  When (astype = 'B') Then astype = 'GDG'      /*                     */
  When (astype = 'R') Then astype = 'PATH'     /*                     */
  When (astype = 'G') Then astype = 'AIX'      /*                     */
  When (astype = 'X') Then astype = 'ALIAS'    /*                     */
  When (astype = 'U') Then astype = 'UCAT'     /*                     */
  Otherwise                          /*                               */
   Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
   Say '**(Error-2)* Entry type ='astype
   astype = '@'                      /* unknown type                  */
 End                                 /*                               */
 type_list = type_list' 'astype      /*                               */
End                                  /*                               */
type = Strip(type_list,L)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREUSE'     /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOWRITECHK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOIMBED'     /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREPLICAT'  /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
 Else                                 /*                              */
  vsam_attr = vsam_attr' NONSPANNED'  /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* For execution in batch, please ensure that a PDS'
   Say '**(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say '**(Error-1)* For execution in foreground TSO, please ensure'
    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say '**(Warning-1)* For execution in batch, it is recommended that'
  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say '**(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = Left('CATALOG',10) csicname /*                            */
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = Left(entype,10) entname dscrdt2 volsers /*                */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

