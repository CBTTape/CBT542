/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX, UNIX Support       */
/**********************************************************************/
/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* The report dataset will now always be dynamically allocated        */
/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */
/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */
/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */
/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */
/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */
/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */
/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/
/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */
/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */
/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */
/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */
/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */
/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */
/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/
/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */
/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */
/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/
/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */
/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */
/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */
/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */
/*                                        make UNIX shell compat      */
/* 1.8.0   - 21/08/2016 - John McKown   - Enhance UNIX usefulness     */
/*                                        Restructure some code       */
/*                                        Remove obsolete code        */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This program writes out various error messages, the return and  */
/*    reason codes can be checked using those found listed for the    */
/*    IBM message IDC3009I. The module is the CSI internal reference  */
/*    and probably isn't of much use to anyone outside IBM.           */
/*                                                                    */
/* 2. Two return codes are 'special' :                                */
/*    RC=100, Reason=4                                                */
/*    RC=44 , Reason=14                                               */
/*    These relate to entries of greater than 65535 characters.       */
/*    If you get these entries, then you need to enable fullword      */
/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */
/*                                                                    */
/**********************************************************************/
/* So how does this differ from the original MCNVTCAT ?               */
/*                                                                    */
/* 1. Well it's written in REXX and uses the Catalog Search Interface */
/*                                                                    */
/* 2. It doesn't check the actual devices available on the system     */
/*    (So you may get a catalog entry for a non-present device type)  */
/*                                                                    */
/* 3. It doesn't add bits of LISTCAT messages into the report totals  */
/*    or the generated members.                                       */
/*                                                                    */
/* 4. It DOES handle datasets cataloged on more than five volume !    */
/*    (So doesn't write out an error message for that condition)      */
/*                                                                    */
/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */
/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */
/*    guess this shouldn't be an issue for many out there.            */
/*                                                                    */
/* 6. It writes its report to the REPORT member of the PDS rather     */
/*    than to a SYSOUT.                                               */
/*                                                                    */
/* 7. It generates a RECAT member that contains statements to allow   */
/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */
/*                                                                    */
/*    Currently this only supports VSAM clusters with the following   */
/*    non-default attributes : LINEAR, REUSE                          */
/*                                                                    */
/* 8. It can be used to compare two catalogs and produces reports     */
/*    showing the differences between the catalogs.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
exitRC = 0
unix_CWD = ''
unix_HOME=''
unix_TMPDIR=''
flag_syscall = 0                     /* Initialize flag to "false"    */
tso_flag = 0                         /* Initialize flag to "false"    */
env_flag = 0                         /* Initialize flag to "false"    */
ispf_flag = 0                        /* Initialize flag to "false"    */
sh_flag=0                            /* Initialize flag to "false"    */
badRC=20
option_used. = 0                     /* flag for use of option        */
Parse SOURCE . . . . . . Environment AddrSpce .
Select
 When AddrSpce = 'MVS' Then
  Do
   Say "**(Error-1)* Environment:"Environment" is unsupported."
   Say '**(Error-2)* Neither TSO nor UNIX shell environment.'
   Say '**(Error-3)* RCNVTCAT cannot allocate files, so terminating.'
   exitRC = 16
   Signal FINISH                      /* leave the exec               */
  End
 When Environment = 'TSO' Then       /* test if under TSO             */
  Do                                 /*                               */
   tso_flag = 1                      /* set TSO flag                  */
   x = Msg('Off')                    /* Disable messages              */
   x = Prompt('Off')                 /* Disable prompts               */
   If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground          */
    env_flag = 1                      /* set ENV flag                 */
   If AddrSpce = 'ISPF' Then          /* test for ISPF                */
    ispf_flag = 1                     /* set ISPF flag                */
   outputLocation='//'               /* Set TSO default output        */
   If sysvar('syspref') = ''
   Then sysuid = sysvar('sysuid')
   Else sysuid = sysvar('syspref')
   sysuid=strip(sysuid,"T"," ");
   badRC=8
  End                                /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
 When AddrSpce = 'OMVS' Then
  Do
   If Environment = 'SH' Then
    flag_syscall = 1 /* because SYSCALLS('ON') is in effect for shell */
   sh_flag = 1
   badRC = 1        /* The "failed" RC under UNIX is 1 not 4          */
   Address SYSCALL "getcwd unix_CWD"
   Address syscall getlogin sysuid
   sysuid=strip(sysuid,"T"," ");
   /* Find the user's ${HOME} */
   /*
     Scan the user's shell environment variables looking
     for HOME=, TMP=, and TMPDIR=. HOME is hopefully self
     explanatory. In standard UNIX programs, any temporary
     files are created in the directory specified in the
     TMPDIR environment variable. If this is not set, then
     the TMP environment variable is set. If it is also not
     set, then /tmp is used.
   */
   Do i=1 to __environment.0 /* Scan the user's environment */
      if 'HOME=' = left(__environment.i,5) Then
       unix_HOME=substr(__environment.i,6)
      if 'TMP=' = left(__environment.i,4) &,
         unix_TMPDIR='' Then
       unix_TMPDIR=substr(__environment.i,5)
      if 'TMPDIR=' = left(__environment.i,7) Then
       unix_TMPDIR=substr(__environment.i,8)
   End
   If unix_TMPDIR='' Then
    unix_TMPDIR='/tmp'
   If unix_HOME = '' Then /* No HOME environment variable? Weird */
    unix_HOME = FindUNIXhome(sysuid)
   If unix_HOME = '' Then /* Wow! No HOME directory at all? */
     unix_HOME=unix_TMPDIR /* act like HOME is TMPDIR */
   Say "HOME is:"unix_HOME
   Say "Temporary files go in:"unix_TMPDIR
   /*
    For a UNIX shell, the default output location is the
    current working directory
   */
   outputLocation=unix_CWD
  End
 Otherwise
  Do                                  /*                              */
   Say "**(Error-1)* Environment:"Environment"/"AddrSpce||,
       " is unsupported."
   Say '**(Error-2)* No TSO environment and '||,
       'no UNIX shell environment.'
   Say '**(Error-3)* RCNVTCAT cannot allocate files, so terminating.'
   exitRC = 16
   Signal FINISH                      /* leave the exec               */
  End                                 /*                              */
End   /* Select */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = ' '                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
rcnvdsn = ''                         /* set dsn to null               */
/**********************************************************************/
/* Handle passed parameters                                           */
/**********************************************************************/
/* This has been greatly changed from the original                    */
/* In order to make things easier in general and to support UNIX      */
/* as I believe it should be, I will emulate the initialization of    */
/* the __argv. variable stem to contain the command's arguments.      */
/* This is automatically done when the command is run in a UNIX       */
/* shell. I must emulate it when invoked in other environments.       */
/**********************************************************************/
If Datatype(__argv.0,"W") <> 1 Then  /* It's not a whole number       */
 Do
  /* This parsing is actually too simplistic and needs to be fixed.   */
  /* It does not proper handle the case where a blank is part of      */
  /* a data value, such as being within ' marks, instead of being a   */
  /* delimiter.                                                       */
  Parse arg vals                     /* Get passed arguments          */
  Parse source . . cmdName .
  __argv.0=Words(vals) + 1
  __argv.1 = cmdName
  Do i = 2 to __argv.0
   __argv.i = Word(vals,i-1)
  End
 End
catNum = 0                           /*                               */
targ_cat=''
Do argNum = 2 To __argv.0            /* loop thru arguments, ignore   */
                                     /* command name (first argument) */
 testarg = Strip(__argv.argNum,"B","'") /* remove inverted commas     */
 testargU = testarg                  /* Retain both original case &   */
                                     /* upper case. UNIX commands     */
                                     /* normally retain case and so   */
                                     /* I will implement that way too.*/
                                     /*                               */
 Upper testargU                      /* convert to upper case to ease */
                                     /* testing.                      */
 Select                              /*                               */
  When (Substr(testargU,1,9) = '--TARGET=') Then
   Do
    targ_cat=Substr(testargU,10)
    targ_cat=strip(targ_cat,"B","'")
   End
  When (Substr(testargU,1,7) = 'TARGET(') Then
   Do
    If ')' <> Right(testargU,1) Then
     Do
      Say '**(Error-1)* No trailing )'
      exitRC = 16
      Signal FINISH                      /* leave the exec               */
     End
    Parse var testargU '(' targ_cat ')'
    targ_cat=strip(targ_cat,"B","'")
   End
  When (testargU = '--TARGET') Then
   Do
    argNum = argNum + 1
    targ_cat = __argv.argNum
    targ_cat=strip(targ_cat,"B","'")
   End
  When (Substr(testargU,1,6) = 'DEBUG(') Then /* check for TSO debug  */
   Do                                /*                               */
    debug = Substr(testargU,7,1)     /* get debug value               */
    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */
   End                               /*                               */
  When ('--debug=' = left(testarg,8)) Then /* UNIX check for debug    */
   Do
    debug = substr(testarg,9)        /* get debug value               */
    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */
   End
  When ('--debug' = testarg) Then    /* UNIX check for debug          */
   Do
 /* debug = Word(vals,argNum+1)       * Get debug value               */
    argNum = argNum + 1              /* bypass next arg, if any       */
    debug = __argv.argNum
    If ('' = debug) Then             /* This happens if --debug is the*/
                                     /* last argument on command line */
     debug = 2                       /* Standard value                */
    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */
   End
  When (testargU = '?' |,            /* Normal for TSO                */
        testarg = '-?' |,            /* Normal for UNIX               */
        testarg = '-h' |,            /* Alternate for UNIX            */
        testarg = '--help',          /* Alternate for GNU longopts    */
       ) Then                        /*                               */
   Call USAGE;
  When (testargU = '-?TSO') Then
   Call USAGE_TSO
  When (testargU = '-?UNIX') Then
   Call USAGE_UNIX
  When (Left(testargU,7) = 'OUTPUT(') Then
   Do
    If ')' <> Right(testargU,1) Then
     Do
      Say '**(Error-1)* OUTPUT option syntax is invalid.'
      Say '**(Error-2)* No end parenthesis.'
      exitRC = badRC
      signal FINISH
     End
    parse var testarg 'OUTPUT(' argvalue ')'
    /* See if argument is inclosed in quotes */
    If "'" = Left(argvalue,1) Then
     Do
      If "'" <> Right(argvalue,1) Then
       Do
        Say '**(Error-1)* Invalid output specification:'argvalue
        exitRC = badRC
        signal FINISH
       End
      Else
       Do
        t = substr(argvalue,2,1) /* test if possible UNIX file */
        If t = '~' |,
           t = '.' |,
           t = '/' Then /* It should likely be UNIX */
         argvalue = substr(argvalue,2,length(argvalue)-2)
       End
     End
    Else /* Argument not in quotes - test for TSO */
     If Environment = 'TSO' Then
      upper argvalue /* only upper case when in TSO */
    If argvalue <> '' Then
     outputLocation = argvalue
    Else
     If sh_flag Then
      outputLocation = unix_CWD
     Else
      outputLocation = '//'
    If Left(outputLocation,1) <> '~' &,
       Left(outputLocation,1) <> '.' &,
       Left(outputLocation,1) <> '/' Then
     outputLocation = '//'outputLocation
    outputLocation = resolveLocation(outputLocation)
   End
  When (Left(testargU,8) = '--OUTPUT') Then
   Do
    parse var testarg '=' argvalue
    If argvalue <> '' Then
     outputLocation = argvalue
    Else
     If sh_flag Then
      outputLocation = unix_CWD      /* In UNIX, current working dir  */
     Else
      outputLocation = '//'          /* In TSO, the random PDS name   */
    outputLocation = resolveLocation(outputLocation)
   End
  When (Left(testargU,2) = '-O' ) Then/* Output Location            */
   Do
    If testargU = '-O' Then
     Do
/*    outputLocation = Word(vals,argNum+1)  */
      argNum = argNum + 1            /* increment loop variable       */
      outputLocation = __argv.argNum
     End
    Else
     outputLocation = substr(testarg,3)
    If '' = outputLocation Then      /* Set default location          */
     If sh_flag Then
      outputLocation = unix_CWD      /* In UNIX, current working dir  */
     Else
      outputLocation = '//'          /* In TSO, the random PDS name   */
    Else
     NOP
    If sh_flag Then /* Special handling for UNIX shell */
     Do
      fChar = Left(outputLocation,1) /* simplify tests */
      if fChar <> '~' &, /* Not UNIX home directory */
         fChar <> '/' &, /* Not absolute directory or DSN */
         fChar <> '.' Then /* Not UNIX relative directory */
       outputLocation = './'outputLocation/* make UNIX relative & hope*/
     End
    outputLocation = resolveLocation(outputLocation)
   End
  When ('-' = left(testarg,1)) Then  /* Must be invalid argument      */
   Do
    Say "**(Error-1)* Invalid option specified:"testarg
    exitRC = badRC
    signal FINISH
   End
  Otherwise                          /* Must be one of the two catalog*/
   Do                                /* name arguments                */
    catNum = catNum + 1              /*                               */
    cat.catNum = testargU            /*                               */
   End
 End                                 /*                               */
End                                  /*                               */
Select                               /*                               */
 When (catNum = 0) Then              /*                               */
  Do                                 /*                               */
   Say '**(cat)** No entry provided for catalog name.'
   exitRC = badRC
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
 When (catNum = 1) Then              /* only one catalog              */
  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */
 When (catNum = 2) Then              /* two catalogs                  */
  process = 'CATCOMP'                /* process for Catalog compare   */
 Otherwise                           /* two catalogs                  */
  Do                                 /*                               */
   Say '**(cat)** Too many arguments='catNum' - retry.'
   exitRC = badRC
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
End                                  /*                               */
/**********************************************************************/
If (DsExist("'"cat.1"'") > 0) Then /*                               */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for catalog name.'
  Say '**(cat)** 'cat.1
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  exitRC = badRC
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
If (process = 'CATCOMP') &,        /* Catalog compare processing    */
   (DsExist("'"cat.2"'") > 0) Then /* bad return                    */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for second catalog name.'
  Say '**(cat)** 'cat.2
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  exitRC = badRC
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
If (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */
 Do                                  /*                               */
  count.id = 0                       /* initialise count              */
  member = 'ALIAS'                   /* processing ALIAS              */
  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'NONVSAM'                 /* processing NONVSAM            */
  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYS1'                    /* processing SYS1               */
  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'IMPORT'                  /* processing IMPORT             */
  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'GDG'                     /* processing GDG                */
  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'MISC'                    /* processing MISC               */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'RECAT'                   /* processing RECAT (MISC+)      */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYSCTLG'                 /* processing SYSCTLG            */
  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'REPORT'                  /* processing REPORT             */
  Call MEM_REPORT                    /* generate report               */
  Call WRITE_MEMBER                  /* write out member              */
 End                                 /*                               */
Else                                 /* Process as Catalog compare    */
 Do                                  /*                               */
  id = 'OLD'                         /* specify for 'old' catalog     */
  count.id = 0                       /* initialise count              */
  cat.old = cat.1                    /* retain catalog name           */
  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */
  id = 'NEW'                         /* specify for 'NEW' catalog     */
  count.id = 0                       /* initialise count              */
  cat.new = cat.2                    /* retain catalog name           */
  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */
  member = 'COMPFULL'                /* processing FULL comparison    */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'COMPSHRT'                /* processing SHORT comparison   */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'EXTRA'                   /* processing EXTRA member       */
  Call NEW_EXT                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'CHANGED'                 /* processing CHANGED member     */
  Call OLD_BAD                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
 End                                 /*                               */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag ) &,                    /*                               */
   (ispf_flag ) Then                 /*                               */
 Do                                  /*                               */
  If '//' = Left(outputLocation,2) Then
   rcnvdsn=substr(outputLocation,3)
  Else
   rcnvdsn=outputLocation
  If '/' = left(rcnvdsn,1) Then
   Address ISPEXEC "EDIT FILE(rcnvdsn)"
  Else
   Address ISPEXEC "EDIT DATASET('"rcnvdsn"')"
  bpxparm = "Free Fi(REPORT)"
  Call BPXWDYN(bpxparm)              /*                               */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit exitRC                          /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat.1,1,44)        /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say '**(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say '**(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000E'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('ATTR1   ',8)        /* Attributes                    */
csifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld11 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld12 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13||csifld14
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say '**(Error-1)* CSI processing.'
   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* Work Area defined  = 'csiusrln
   Say '**(Error-2)* Work Area used     = 'csiusdln
   Say '**(Error-3)* Work Area required = 'csireqln
   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say 'off=<'off'>'                /*                               */
    Say 'entry =<'Substr(dwork,off,150)'>'
    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* No data returned'
       Say '**(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
attr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */
cattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */
volser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */
fileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */
vsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ATTR1') > 0) Then    /*                           */
 Call FLD_ATTR1                          /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) <> 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ATTR1    - Process ATTR1    field                              */
/**********************************************************************/
FLD_ATTR1:                           /* ATTR1    field processing   ##*/
attr1 = X2b(c2x(attr1))              /*                               */
If (Substr(attr1,1,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' SPEED'       /*                               */
If (Substr(attr1,3,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' REUSE'       /*                               */
If (Substr(attr1,4,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' ERASE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype <> 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
If (entype <> 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member <> 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag <> 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If '//' = left(outputLocation,2) Then
   call AllocReportFile 'MEMOT',outputLocation'('member')'
  Else
   call AllocReportFile 'MEMOT',outputLocation'/'member'.txt'
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  bpxparm = "Free Fi(MEMOT)"         /*                               */
  Call BPXWDYN(bpxparm)              /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /* sets variable:rcnvdsn         */
If (rc = 0) Then
 If rcvtpath = '' Then
  outputLocation='//'||rcnvdsn
 Else
  outputLocation=rcvtpath
If (rc = 16) Then                    /* REPORT not allocated          */
 If sh_flag Then
  Do
   Address syscall getlogin sysuid
   sysuid=strip(sysuid,"T"," ");
   If '' = outputLocation Then
    outputLocation=unix_CWD
   If ('//' = Left(outputLocation,2)) Then
    Do
     If '//' = outputLocation Then
      Do
       random_dsn = 'T'random(9999)
       rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn
       outputLocation="//"||rcnvdsn
      End
      Call AllocReportFile 'REPORT',outputLocation
    End
   Call bpxwdyn("free fi(REPORT)")
  End
 Else
  Do /* Must be TSO */              /*                               */
   If '' = outputLocation Then
    outputLocation='//'
   If '//' = Left(outputLocation,2) Then
   Select
    When '//' = Left(outputLocation,2) Then
    Do
     If '//' = outputLocation Then
      Do
       random_dsn = 'T'random(9999)
       rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn
       outputLocation = "//"||rcnvdsn
      End
 /*  rcnvdsn=substr(outputLocation,3) */
     Call AllocReportFile 'REPORT',outputLocation
    End
   Otherwise /* better start with a single slash! */
    Do
      If '/' <> Left(outputLocation,1) Then
       Do
        Say "**(Error-1)* Invalid output destination:"outputLocation
        exitRC = badRC
        signal FINISH
       End
    End
   End
  End                               /*                               */
If '//' = Left(outputLocation,2) Then
 dsn="DSN:"substr(outputLocation,3)
Else
 Do
  /*
    Validate UNIX path for efficiency and better diagnostics
  */
  If flag_syscall <> 1 Then
   If SYSCALLS('ON') > 3 Then
    Do
     Say "Unable to establish a UNIX environment. Aborting"
     exit(8)
    End
  flag_syscall = 1
  Address SYSCALL "stat (outputLocation) st."
/*Say "!"outputLocation"!"rc"!"retval"!"st.ST_TYPE"!"S_ISDIR"!",
    unix_HOME"|" */
  If retval = -1 Then
   Do
    Say '**(Error-1)* Invalid output destination:'outputLocation
    Say '**(Error-2)* One of the directories in the path does'||,
        ' not exist.'
    exitRC = badRC
    signal FINISH
   End
  If st.ST_TYPE <> S_ISDIR Then
   Do
    Say '**(Error-1)* Invalid output destination:'outputLocation
    Say '**(Error-2)* 'outputLocation' is not a directory.'
    exitRC = badRC
    signal FINISH
   End
  dsn="Path:"outputLocation
 End
say 'RCNVTCAT Report '||dsn /*'outputLocation:'outputLocation*/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
ali_tot = 0                          /* Total Aliases                 */
asy_tot = 0                          /* Total Aliases SYSCATLG        */
anv_tot = 0                          /* Total Aliases NONVSAM         */
axx_tot = 0                          /* interim alias total           */
avu_tot = 0                          /* Total Aliases VSAM UCAT       */
gdg_tot = 0                          /* Total GDGs                    */
ivd_tot = 0                          /* Total invalid devices         */
msc_tot = 0                          /* Total MISC datasets           */
nvd_tot = 0                          /* Total NONVSAM datasets        */
nvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */
nvv_tot = 0                          /* Total NONVSAM dsn volumes     */
syc_tot = 0                          /* Total SYSCTLG datasets        */
sy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */
uct_tot = 0                          /* Total Usercatalog imports     */
Return                               /*                               */
/**********************************************************************/

DsExist: /*Procedure Expose sysreason sysmsglvl1 sysmsglvl2 badRC ,
           (syscall_constants) */
parse arg indsn
sysreason=0
sysmsglvl1=' Not Emulated '
sysmsglvl2=' Not Emulated '
If indsn = '' Then
 Do
   sysreason=29
   return 16
 End
xx=outtrap('junk.','*') /* I don't care */
Address TSO "LISTCAT ENT("indsn")"
xx=outtrap("OFF")
lrc=rc
sysreason=rc
hexrc=right(d2x(rc),8,"0")
If "0438" = left(hexrc,4) Then
 Do
  sysreason=24
  Return 16
 End
drop junk.
return lrc
LISTDD:   /* new routine */
rc=bpxwdyn("INFO ",
           "DD(REPORT) ",
           "INRTDSN(rcnvdsn) ",
           "INRTPATH(rcvtpath) ",
           "MSG(message.)")
/*
           "INRDSNT(dsntype) ",
           "INRTORG(dsorg) ",
*/
If rc <> 0 Then
 Do
  rcnvdsn=''
  return 16
 End
 If rcnvdsn='...PATH=.SPECIFIED...' Then
  rcnvdsn = rcvtpath
return 0
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
AllocReportFile: /* Procedure EXPOSE sysuid unix_HOME badRC ,
                    (syscall_constants) */
 parse arg DDname,whereOutput,rest
 If rest<> '' |,
    whereOutput = '' Then
  Do
   Say "Invalid call to AllocReportFile."
   exit(16)
  End
 Select
  When '//' = left(whereOutput,2) Then
   Do
    j = Pos('(',whereOutput)
    If j = 0 Then
     j = Length(whereOutput) + 1
    If (DsExist("'"substr(left(whereOutput,j-1),3)"'") <> 0) &,
       (j >= Length(whereOutput)) Then
     Allocation="Unit(SYSALLDA) Space(2,2) Dir(10) Cyl New Catalog"
    Else
     Allocation='Old ' /* Original code had Shr */
    varOutput = "Da('"substr(whereOutput,3)"') Reuse "Allocation
   End
  When '/' = Left(whereOutput,1) Then
   varOutput = "Path('"whereOutput"') ",
               "FILEDATA(TEXT) ",
               "PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) ",
               "PATHOPTS(OTRUNC,OWRONLY,OCREAT)"
 /*
 */
  When '~/' = Left(whereOutput,2) |,
       '.' = Left(whereOutput,1) Then
   Do
    If Address() = 'TSO' &,
       left(unix_HOME,1) <> '/'
    Then
     Do
      If flag_syscall <> 1 Then
       If SYSCALLS('ON') > 3 Then
        Do
         Say "Unable to establish a UNIX environment. Aborting"
         exit(8)
        End
      flag_syscall = 1
      Address SYSCALL "setpwent"
      Do FOREVER
       Address SYSCALL "getpwent passwd."
       If retval = 0 | retval = -1 Then
        Do
         exitRC = 1
         say "**(Error-1)* Cannot find user:"sysuid
         signal FINISH
        End
       If strip(passwd.PW_NAME,"T"," ") = sysuid Then LEAVE
      End
      unix_HOME = passwd.PW_DIR /* Get the home directory from RACF */
     End
    If '~' = Left(whereOutput,1) Then
     whereOutput=unix_HOME||Substr(whereOutput,2)
    Else /* Must be a . */
     whereOutput=unix_CWD||"/"||whereOutput
    varOutput = "Path('"whereOutput"') ",
               "PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) ",
               "FILEDATA(TEXT) ",
               "PATHOPTS(OTRUNC,OWRONLY,OCREAT)"
   End
  When '~' = Left(whereOutput,1) Then
   Do
    j = Pos('/',whereOutput)
    if (0 = j) Then
     Do
      whereOutput=whereOutput||'/'
      j = length(whereOutput)
     End
    tuser=substr(left(whereOutput,j - 1),2)
    upper tuser
    If flag_syscall <> 1 Then
     If SYSCALLS('ON') > 3 Then
      Do
       Say "Unable to establish a UNIX environment. Aborting"
       exit(8)
      End
    flag_syscall = 1
    Address SYSCALL "setpwent"
    Do FOREVER
     Address SYSCALL "getpwent passwd."
     If retval = 0 | retval = -1 Then
      Do
       exitRC = 1
       say "**(Error-1)* Cannot find user:"tuser
       signal FINISH
      End
     If strip(passwd.PW_NAME,"T",' ') = tuser Then LEAVE
    End
    unix_HOME=passwd.PW_DIR
    whereOutput=passwd.PW_DIR||substr(whereOutput,j)
    varOutput = "Path('"whereOutput"') ",
               "PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) ",
               "FILEDATA(TEXT) ",
               "PATHOPTS(OTRUNC,OWRONLY,OCREAT)"
   End
   Otherwise
    Do
     Say 'Unknown parameter value whereOutput='whereOutput
     exit(8)
    End
 End
 bpxparm = "Alloc ",
           varOutput,
           "Fi("DDname") ",
           "Lrecl(133) ",
           "Blksize(1330) ",
           "Recfm(F,B) "
 rc=BPXWDYN(bpxparm)
 If rc <> 0 Then
  Do
   Say "Allocation string:"bpxparm
   bpxmtext=''
   Say "S99MSG messages:"S99MSG.0
   Do j=1 to S99MSG.0
      Say S99MSG.j
      parse var S99MSG.j . 'REASON CODE IS (' bpxmtext ')'
      If '' <> bpxmtext Then
       Do
        stdin.0=0
        rc=bpxwunix("/bin/bpxmtext "||bpxmtext,stdin.,stdout.,stderr.)
        Do k=1 to stdout.0
         Say "BPXMTEXT-1:"||stdout.k
        End
        Do k=1 to stderr.0
         Say "BPXMTEXT-2:"||stderr.k
        End
       End
   End
   Say '**(Error-1)* Allocation of DD:'DDname' Failed.'
   Select
    When rc = 20 Then
     Say '**(Error-2)* BPXWDYN Invalid Parameter List.'
    When rc > 0 | rc <-1610612737 Then
     Do
      hexrc=rc
      Say '**(Error-2)* Dynamic Allocation error code:'hexrc
     End
    When rc <= -21 & rc >= -9999 Then
     Do
      Say '**(Error-2)* Error in key number 'abs(rc)-20
      Say 'Call list:'bpxparm
     End
    When rc <= -10000 & rc >= -10099 Then
     Do
       Say '**(Error-2)* Message processing error. IEFDB476 returned code:',
           abs(rc)-10000
       Say 'Call list:'bpxparm
     End
    Otherwise
     Say '**(Error-2)* Other error. Return code is 'rc
   End
   exitRC=badRC
   signal FINISH
  End
 Return
/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
                                     /*                               */
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  Say '**(cat)** Processing 'Left('CATALOG',10) csicname
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  If (process = 'CATCOMP') Then      /** Catalog compare code        **/
   Do                                /*                               */
    count.id           = count.id+1  /* increment count               */
    val                = count.id    /* save value                    */
    entname.id.val     = entname     /* store entry name              */
    entype.id.val      = entype      /* store entry type              */
    name.id.val        = name        /* store assoc name              */
    type.id.val        = type        /* store assoc type              */
    pageswap.id.val    = pageswap    /* store pageswap                */
    devices.id.val     = devices     /* store devices                 */
    fils.id.val        = fils        /* store fils                    */
    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */
    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */
    gdglimit.id.val    = gdglimit    /* store gdglimit                */
    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */
    vsam_type.id.val   = vsam_type   /* store vsam_attr               */
    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */
    volsers.id.val     = volsers     /* store volsers by value        */
                                     /** Back reference values       **/
    volsers.id.entname = volsers     /* store volsers by entry name   */
    name.id.entname    = name        /* store name by entry name      */
    val.id.entname     = val         /* store value by entry name     */
   End                               /** End Catalog compare code    **/
  Else                               /*                               */
   Do                                /*                               */
    Select                           /*                               */
     When (member = 'MISC') Then     /* MISC member                   */
      Call MEM_MISC                  /*                               */
     When (member = 'RECAT') Then    /* RECAT member                  */
      Call MEM_RECAT                 /*                               */
     When (member = 'ALIAS') Then    /* ALIAS member                  */
      Call MEM_ALIAS                 /*                               */
     When (member = 'GDG') Then      /* GDG member                    */
      Call MEM_GDG                   /*                               */
     When (member = 'IMPORT') Then   /* IMPORT member                 */
      Call MEM_IMPORT                /*                               */
     When (member = 'NONVSAM') Then  /* NONVSAM member                */
      Do                             /*                               */
       axx_tot = anv_tot             /* set intermim alias total      */
       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */
       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */
       If (Substr(entname,1,4) <> 'SYS1') &,
          (Substr(entname,1,7) <> 'SYSCTLG') Then /* not SYS1/SYSCTLG */
        Do                           /*                               */
         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */
         Call MEM_NONVSAM            /*                               */
        End                          /*                               */
       anv_tot = axx_tot             /* set non-vsam aliases total    */
      End                            /*                               */
     When (member = 'SYS1') Then     /* SYS1 member                   */
      Do                             /*                               */
       sy1_tot = sy1_tot + 1         /* increment sys1 total          */
       Call MEM_NONVSAM              /*                               */
      End                            /*                               */
     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */
      Do                             /*                               */
       axx_tot = asy_tot             /* interim = syscatlg aliases    */
       syc_tot = syc_tot + 1         /* increment syscatlg total      */
       Call MEM_NONVSAM              /*                               */
       asy_tot = axx_tot             /* set syscatlg total            */
      End                            /*                               */
     Otherwise NOP                   /*                               */
    End                              /*                               */
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_MISC - Generate MISC member lines                              */
/**********************************************************************/
MEM_MISC:                            /* Generate MISC member lines  ##*/
If (entype = 'CLUSTER') |,
   (entype = 'PAGESPACE') Then
 Do
  msc_tot = msc_tot + 1
  l_cnt = l_cnt + 1
  text = ' /* 'Left(entype' ',15,'-')
  text = text' 'Left(entname,32)'  NOT PROCESSED */'
  l.l_cnt = text
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_RECAT - Generate RECAT member lines                            */
/**********************************************************************/
MEM_RECAT:                           /* Generate RECAT member lines ##*/
If (entype = 'PAGESPACE') Then
 Do
  page_name     = entname
  page_swap     = pageswap
  If (Index(type,'D') <> 0) Then
   data_flag = 'DATA'
  Else
   data_flag = ''
 End
If (entype = 'CLUSTER') Then
 Do
  If (Substr(entname,1,4) <> 'SYS1') Then
   Do
    cluster_name  = entname
    l_cnt = l_cnt + 1
    text = ' /* 'Left(entype' ',15,'-')
    text = text' 'Left(entname,34)' CANNOT RECAT */'
    data_flag = ''
    index_flag = ''
    l.l_cnt = text
   End
  Else
   Do
    cluster_name  = entname
    If (Index(type,'D') <> 0) Then
     data_flag = 'DATA'
    Else
     data_flag = ''
    If (Index(type,'I') <> 0) Then
     index_flag = 'INDEX'
    Else
     index_flag = ''
    cluster_bits  = type
   End
 End
If (entype = 'DATA') &,
   (data_flag = 'DATA') Then
 Select
  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */
   Do
    l_cnt = l_cnt + 1
    text = ' /* 'Left('VVDS ',15,'-')
    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'
    l.l_cnt = text
   End
  When (Index(name,page_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left(page_swap,57)' -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    If targ_cat='' Then
     l.l_cnt = '          CAT('Left(cat,44)'        )'
    Else
     l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
   End
  When (Index(name,cluster_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    If (vsam_attr <> '') Then
     Do
      l_cnt = l_cnt + 1
      l.l_cnt = '          'Left(vsam_attr,57)' -'
     End
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'
    If (index_flag = '') Then
     Do
      l_cnt = l_cnt + 1
     If targ_cat='' Then
      l.l_cnt = '          CAT('Left(cat,44)'        )'
     Else
      l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
     End
   End
  Otherwise
   Say '**(Error--1)* Unexpected condition for :'
   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)
   Say '**(Error--3)* page_name    = 'Strip(page_name,T)
   Say '**(Error--4)* entname      = 'Strip(entname,T)
   Say '**(Error--5)* entype       = 'Strip(entype,T)
   Say '**(Error--6)* name         = 'Strip(name,T)
   Say '**(Error--7)* type         = 'Strip(type,T)
   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)
   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)
   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1
   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2
   Say '**(Error-12)* vsamreus     = 'vsamreus
 End
If (entype = 'INDEX') &,
   (index_flag = 'INDEX') Then
 Do
  l_cnt = l_cnt + 1
  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('Left(cat,44)'        )'
  If targ_cat='' Then
   l.l_cnt = '          CAT('Left(cat,44)'        )'
  Else
   l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_ALIAS - Generate ALIAS member lines                            */
/**********************************************************************/
MEM_ALIAS:                           /* Generate ALIAS member lines ##*/
ali_tot = ali_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '     DEF ALIAS(NAME('entname')  -'
l_cnt = l_cnt + 1
l.l_cnt = '          REL('name'))          -'
l_cnt = l_cnt + 1
l.l_cnt = '          CAT('Left(cat,44)'         )'
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'         )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_IMPORT - Generate IMPORT member lines                          */
/**********************************************************************/
MEM_IMPORT:                          /* Generate IMPORT member lins ##*/
uct_tot = uct_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '    IMPORT   OBJ( ('entname'  -'
l_cnt = l_cnt + 1
l.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'
l.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'
l_cnt = l_cnt + 1
l.l_cnt = '          CAT('Left(cat,46)'       )'
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'        )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_GDG - Generate GDG member lines                                */
/**********************************************************************/
MEM_GDG:                             /* Generate GDG member lines   ##*/
gdg_tot = gdg_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  GDG  (NAME('entname') -'
l_cnt = l_cnt + 1
l.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)
l.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'
l_cnt = l_cnt + 1
l.l_cnt = '          CAT('Left(cat,46)'       )'
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'        )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_NONVSAM - Generate NONVSAM member lines                        */
/**********************************************************************/
MEM_NONVSAM:                         /* Generate NONVSAM member lins##*/
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  NVSAM(NAME('entname') -'
If (Words(devices) <= 5) Then        /* < 5 devices for dataset       */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          DEVT( 'Left(devices,47)') -'
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq <> '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'
   End                               /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          VOL(  'Left(volser,47)') )-'
 End                                 /*                               */
Else                                 /* > 5 devices for dataset       */
 Do                                  /*                               */
  item_lead = 'DEVT( '               /* devices header                */
  item_end  = ') -'                  /* devices trailer               */
  item_pad  = ''                     /* no padding                    */
  items = devices                    /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq <> '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    item_lead = 'FSEQN('             /* fileseq header                */
    item_end  = ') -'                /* fileseq trailer               */
    item_pad  = Left('',7)           /* 7 spaces padding              */
    items = fileseq                  /* pass data                     */
    Call PLUS5_HANDLE                /* handle > 5 items              */
   End                               /*                               */
  item_lead = 'VOL(  '               /* volumes header                */
  item_end  = ') ) -'                /* volumes trailer               */
  item_pad  = ''                     /* no padding                    */
  items = volser                     /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
 End                                 /*                               */
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = '          CAT('Left(cat,46)'       )'
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'        )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ASSOC_ENTRY - Process associated entries                           */
/**********************************************************************/
ASSOC_ENTRY:                         /* Process associated entries  ##*/
Do ali = 1 to Words(name)
 If (Substr(type,ali,1) = 'X') Then
  Do
   axx_tot = axx_tot + 1
   l_cnt = l_cnt + 1
   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'
   l_cnt = l_cnt + 1
   l.l_cnt = '          REL('entname'))  -'
   l_cnt = l_cnt + 1
   l.l_cnt = '          CAT('Left(cat,44)'         )'
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'         )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */
/**********************************************************************/
PLUS5_HANDLE:                        /* Handle > 5 fields           ##*/
l_cnt = l_cnt + 1
w_end = Wordindex(items,6)
data = Left(Substr(items,1,w_end-1),47)
l.l_cnt = '          'item_lead||data' -'
Do mult = 6 to Words(items) by 5
 w_sta = Wordindex(items,mult)
 w_end = Wordindex(items,mult+5)
 If (w_end = 0) Then
  item = Substr(items,w_sta)
 Else
  item = Substr(items,w_sta,w_end-w_sta)
 l_cnt = l_cnt + 1
 item_length = 47 - Length(item_pad)
 l.l_cnt = '                '||item_pad||Left(item,item_length)' -'
End
l.l_cnt = Strip(l.l_cnt,T,'-')||item_end
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_REPORT - Generate REPORT member                                */
/**********************************************************************/
MEM_REPORT:                          /* Generate REPORT member      ##*/
r.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'
r.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'
r.3  = ' '
r.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '
r.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '
r.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '
r.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '
r.8  = '                                                        '
r.9  = 'NUMBER OF VSAM USER CATALOGS                            '
r.10 = '                                                        '
r.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '
r.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '
r.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '
r.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '
r.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '
r.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'
r.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '
r.18 = 'ALL OTHER NON VSAM DATA SETS                            '
r.19 = '                                                        '
r.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '
r.21 = '                                                        '
r.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '
r.23 = '                                                        '
r.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '
r.25 = 'DEVICE TYPE. SEE NOTE 3                                 '
r.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '
r.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '
r.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '
tot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot
sta_tot = tot_tot + ali_tot
r.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4
r.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5
r.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6
r.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7
r.8  = '                                          '||r.8
r.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9
r.10 = '                                          '||r.10
r.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11
r.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12
r.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13
r.14 = '                                          '||r.14
r.15 = ' SYSCTLG CONVERTED ........        0      '||r.15
r.16 = '                                          '||r.16
r.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17
r.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18
r.19 = '                                          '||r.19
r.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20
r.21 = '                                          '||r.21
r.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22
r.23 = '------------------------------------      '||r.23
r.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24
r.25 = '                                          '||r.25
r.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26
r.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27
r.28 = '                                          '||r.28
r.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'
r.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '
r.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'
r.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'
r.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'
r.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'
r.32 = r.32||'. BETTER CHECK THE CODE !?!'
r.33 = r.33||'HEY ARE PROCESSED TWICE'
l_cnt = 33
Do loop = 1 to 33
 l.loop = r.loop
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* COMP_REPORT - Produce the Catalog comparison report                */
/**********************************************************************/
COMP_REPORT:                         /* Produce the catalog compare ##*/
l_cnt = 0
Do loop = 1 to count.OLD
 entname = entname.OLD.loop
 entype  = entype.OLD.loop
 name    = name.OLD.loop
 volsers = volsers.OLD.loop
 flag.entname = 'Y'
 If (member = 'COMPFULL') Then
  Do
   disp_ent = entname
   disp_entype = Left(entype,8)
  End
 Else
  Do
   disp_ent = Left(entname,36)
   disp_entype = Left(substr(entype,1,3),4)
  End
 disp_vol = Strip(volsers,B)
 If (Symbol('val.NEW.entname') = 'LIT') Then
  Do
   l_cnt = l_cnt + 1
   Select
    When (entype = 'ALIAS  '  ) Then
     detail = Strip(name.OLD.loop,B)
    When (entype = 'DATA'     ) |,
         (entype = 'INDEX'    ) Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)||' ',
              Strip(vsam_type.OLD.loop,B)||' ',
              Strip(vsam_attr.OLD.loop,B)
    When (entype = 'NONVSAM'  ) |,
         (entype = 'GDG'      ) |,
         (entype = 'UCAT'     ) |,
         (entype = 'PAGESPACE') Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)
    Otherwise NOP
   End
   l.l_cnt = disp_entype||disp_ent' --missing - 'detail
   status.OLD.loop = 'MISSING'
  End
 Else
  Do
   namenew = name.NEW.entname
   volsnew = volsers.NEW.entname
   Select
    When (namenew <> name) Then
     Do
      If (entype = 'ALIAS') Then
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADCAT'
       End
      Else
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##related entries do not match.'
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADENT'
       End
     End
    When (volsnew <> volsers) Then
     Do
      l_cnt = l_cnt + 1
      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)
      l.l_cnt = disp_entype||disp_ent||err_text
      status.OLD.loop = 'BADVOL'
     End
    Otherwise
     l_cnt = l_cnt + 1
     l.l_cnt = disp_entype||disp_ent' **entry matches.'
     status.OLD.loop = 'OK'
   End
  End
End
Do loop = 1 to count.NEW
 entname = entname.NEW.loop
 entype  = entype.NEW.loop
 volsers = volsers.NEW.loop
 If (flag.entname <> 'Y') Then
  Do
   If (member = 'COMPFULL') Then
    Do
     disp_ent = entname
     disp_entype = Left(entype,8)
    End
   Else
    Do
     disp_ent = Left(entname,36)
     disp_entype = Left(substr(entype,1,3),4)
    End
   disp_vol = Strip(volsers,B)
   l_cnt = l_cnt + 1
   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol
   status.NEW.loop = 'NEW'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* NEW_EXT - Process for new entries                                  */
/**********************************************************************/
NEW_EXT:                             /* Process new entries         ##*/
Do loop = 1 to count.NEW             /*                               */
 If (status.NEW.loop = 'NEW') Then   /*                               */
  Do                                 /*                               */
   entname = entname.NEW.loop        /*                               */
   entype  = entype.NEW.loop         /*                               */
   If (entype = 'DATA') |,           /*                               */
      (entype = 'INDEX') Then        /*                               */
    Iterate                          /*                               */
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry not present in catalog "cat.old". */"
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry present in catalog     "cat.new". */"
   Call ENTRY_DEL                    /* process an entry delete       */
  End                                /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* OLD_BAD - Process for old entries                                  */
/**********************************************************************/
OLD_BAD:                             /* Process old entries         ##*/
Do loop = 1 to count.OLD             /*                               */
 entname   = entname.OLD.loop        /*                               */
 entype    = entype.OLD.loop         /*                               */
 volsers   = volsers.OLD.loop        /*                               */
 volser    = Strip(volsers,B)        /*                               */
 name      = name.OLD.loop           /*                               */
 type      = type.OLD.loop           /*                               */
 pageswap  = pageswap.OLD.loop       /*                               */
 devices   = devices.OLD.loop        /*                               */
 fils      = fils.OLD.loop           /*                               */
 gdg_emp   = gdg_emp.OLD.loop        /*                               */
 gdg_scr   = gdg_scr.OLD.loop        /*                               */
 gdglimit  = gdglimit.OLD.loop       /*                               */
 vsam_attr = vsam_attr.OLD.loop      /*                               */
 vsam_type = vsam_type.OLD.loop      /*                               */
 vsam_vvds = vsam_vvds.OLD.loop      /*                               */
 namenew   = name.NEW.entname        /*                               */
 volsnew   = volsers.NEW.entname     /*                               */
 If (entype = 'DATA') |,             /*                               */
    (entype = 'INDEX') Then          /*                               */
  Iterate                            /*                               */
 Select                              /*                               */
  When (status.OLD.loop = 'MISSING') Then /*                          */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Entry missing in catalog "cat". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADCAT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Alias incorrectly pointing to "namenew". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADENT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Related entries do not match */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* entry "Strip(entname,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* old "Strip(name,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* new "Strip(namenew,T)" */"
   End                               /*                               */
  When (status.OLD.loop = 'BADVOL') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Volume incorrect - was "volsnew". */"
   End                               /*                               */
  Otherwise Iterate                  /*                               */
 End                                 /*                               */
 Call ENTRY_DEL                      /* process an entry delete       */
 Call ENTRY_CHG                      /* process an entry change       */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_DEL - Create a DELETE statement                              */
/**********************************************************************/
ENTRY_DEL:                           /* Create an entry DELETE      ##*/
If (entype = 'NONVSAM') Then         /*                               */
 tparm = ''                          /*                               */
Else                                 /*                               */
 tparm = entype                      /*                               */
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      DELETE "Strip(entname,T)" "tparm" NOSCRATCH -"
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "             CAT("Left(cat,44)"         )"
If targ_cat='' Then
 l.l_cnt = '          CAT('Left(cat,44)'        )'
Else
 l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      SET MAXCC=0"
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_CHG - Create a changed entry statement                       */
/**********************************************************************/
ENTRY_CHG:                           /* Create a changed entry      ##*/
Select                               /*                               */
 When (entype = 'NONVSAM') Then      /*                               */
  Call MEM_NONVSAM                   /*                               */
 When (entype = 'ALIAS') Then        /*                               */
  Call MEM_ALIAS                     /*                               */
 When (entype = 'GDG') Then          /*                               */
  Call MEM_GDG                       /*                               */
 Otherwise NOP                       /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* CheckOption - Check that a given option is used at most once.      */
/**********************************************************************/
CheckOption: Procedure EXPOSE unix_HOME sysuid badRC ,
             (syscall_constants)
 Parse arg optionName .
 option_used.optionName = 1
 Return

/**********************************************************************/
/* FindUNIXhome                                                       */
/**********************************************************************/
FindUNIXhome: /* Procedure  expose unix_HOME sysuid badRC
                 (syscall_constants) */
 arg tuser2
 If tuser2 = sysuid &,
    '/' = left(unix_HOME,1) Then
  return unix_HOME
  If flag_syscall <> 1 Then
   If SYSCALLS('ON') > 3 Then
    Do
     Say "Unable to establish a UNIX environment. Aborting"
     exit(8)
    End
  flag_syscall = 1
  Address SYSCALL "setpwent"
  Do FOREVER
   Address SYSCALL "getpwent passwd."
   If retval = 0 | retval = -1 Then
    Do
     exitRC = badRC
     say "**(Error-1)* Cannot find user:"tuser2
     signal FINISH
    End
   If strip(passwd.PW_NAME,"T"," ") = tuser2 Then LEAVE
  End
  return passwd.PW_DIR /* Get the home directory from RACF */

resolveLocation:
 parse arg tempLocation rest
 If rest <> '' Then
  Do
   Say '**(Error-1)* Invalid call to resolveLocation,'
   Say '**(Error-2)* extraneous parameter(s):'rest
  End
 Select
  When '//' = left(tempLocation,2) &,
     Length(tempLocation) <> 2 Then
   Do
    upper tempLocation
    If "'" <> substr(tempLocation,3,1) Then
     tempLocation = "//"||sysuid||"."||substr(tempLocation,3)
    Else
     If "'" <> right(tempLocation,1) Then
      Do
       Say "Invalid DSN specification, no ending quote:"||,
           tempLocation
       exitRC = badRC
       signal FINISH
      End
     Else
      tempLocation="//"||,
       substr(tempLocation,4,Length(tempLocation)-4)
   End
 /* Resolve UNIX home - just in case */
  When '~' = left(tempLocation,1) Then
   Do
    parse var tempLocation '~' tuser '/' Directory
    If tuser='' Then
     tuser=sysuid
    unix_HOME = FindUNIXhome(tuser)
    If Directory = '' Then
     tempLocation=unix_Home
    Else
     tempLocation=unix_Home||"/"||Directory
   End
  Otherwise
   Do
    Say "resolveLocation:"tempLocation
   End
  End
 return tempLocation
/* End of UNIX home resolution */

/**********************************************************************/
/* USAGE     - Print appropriate USAGE information                    */
/**********************************************************************/
USAGE: Procedure
 Call USAGE_TSO /* just use one help for now */
 exit(0)
 RunningState=Address()
 Select
  When RunningState = 'SH' Then
   Call USAGE_UNIX
  When RunningState = 'TSO' Then
   Call USAGE_TSO
  Otherwise
   Say "Unsupported environment:"RunningState
 exit(0)
/**********************************************************************/

/**********************************************************************/
/* USAGE_TSO - Print TSO Usage information                            */
/**********************************************************************/
USAGE_TSO: Procedure
 Say "RCNVTCAT requires either one or two parameters and can accept"
 Say " three other optional arguments."
 Say " - RCNVTCAT catname       : produces MCNVTCAT type output"
 Say " - RCNVTCAT oldcat newcat : produces catalog comparison output"
 Say ' '
 Say '==Debug Option:'
 Say ' Enabled with the debug argument. This argument has three forms:'
 Say 'DEBUG(n)'
 Say '--debug n'
 Say '--debug=n'
 Say 'This sets the debug value to "n". The only valid value at this'
 Say "time is 2. It just put out some diagnostics which I don't"
 Say 'know the utility of.'
 Say ' '
 Say '==Output Option:'
 Say ' Enabled with the output argument. This argument has 6 variants,'
 Say ' but they all do the same thing. They say where to place the'
 Say ' output. They are all equivalent. The reason for so many variants'
 Say ' is to hopefully seem "intuitive" to a wide spectrum of users.'
 Say ' '
 Say ' If an output option is not used, then the default output'
 Say ' location is to the data set allocated to the DD REPORT. If'
 Say ' this DD is not allocated, then the location used depends on'
 Say ' the execution environment.'
 Say ' Note that the specification of one of the output location'
 Say ' options will override the use of the DD REPORT even if it'
 Say ' is allocated.'
 Say ' '
 Say ' When run as a UNIX shell program, the default output location'
 Say ' is the current working directory. Otherwise, the location is'
 Say ' a PDS with a generated name.'
 Say ' The output location is displayed to the user.'
 Say 'OUTPUT(location)'
 Say 'OUTPUT=location'
 Say '-O location'
 Say '-Olocation'
 Say '-o location'
 Say '-olocation'
 Say ' In the above "location" is where to put the output. It may be'
 Say ' either a z/OS data set name or a z/OS UNIX directory name.'
 Say ' The DSN need not exist. A PDS with the given name will be'
 Say ' created if necessary.'
 Say ' A UNIX directory must exist if it is specified.'
 Say ' '
 Say ' When the location appears to be a data set name, as opposed to'
 Say " a UNIX path, the name is prefixed by the user's TSO prefix as"
 Say ' is done in most TSO command processors, unless it is enclosed'
 Say " within ' symbols."
 Say ' The location is assumed to be a DSN unless it begins with a'
 Say ' / (slash), . (period), or ~ (tilde); in which case it is'
 Say ' assumed to be a UNIX directory name. As with most UNIX'
 Say ' commands, a file name which begins with a / is an absolute'
 Say ' path to the directory, a period indicates a path relative to'
 Say ' the current directory, and a ~ (tilde) indicates a path'
 Say ' relative to the UNIX HOME directory of the current user (if'
 Say ' immediately followed by a / (slash) ) or a given user (the'
 Say ' value after the tilde but before the first / (slash) ). In'
 Say ' either case, the user must have the appropriate authority to'
 Say ' the directory or DSN.'
 Say ' '
 exit(0)

/**********************************************************************/
/* USAGE_UNIX- Print UNIX Usage information                           */
/**********************************************************************/
USAGE_UNIX: Procedure
 exit(0)
/**********************************************************************/
