/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */
/**********************************************************************/
/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* The report dataset will now always be dynamically allocated        */
/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */
/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */
/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */
/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */
/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */
/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */
/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/
/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */
/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */
/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */
/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */
/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */
/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */
/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/
/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */
/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */
/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/
/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */
/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */
/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */
/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */
/*                                        make UNIX shell compatible  */
/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This program writes out various error messages, the return and  */
/*    reason codes can be checked using those found listed for the    */
/*    IBM message IDC3009I. The module is the CSI internal reference  */
/*    and probably isn't of much use to anyone outside IBM.           */
/*                                                                    */
/* 2. Two return codes are 'special' :                                */
/*    RC=100, Reason=4                                                */
/*    RC=44 , Reason=14                                               */
/*    These relate to entries of greater than 65535 characters.       */
/*    If you get these entries, then you need to enable fullword      */
/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */
/*                                                                    */
/**********************************************************************/
/* So how does this differ from the original MCNVTCAT ?               */
/*                                                                    */
/* 1. Well it's written in REXX and uses the Catalog Search Interface */
/*                                                                    */
/* 2. It doesn't check the actual devices available on the system     */
/*    (So you may get a catalog entry for a non-present device type)  */
/*                                                                    */
/* 3. It doesn't add bits of LISTCAT messages into the report totals  */
/*    or the generated members.                                       */
/*                                                                    */
/* 4. It DOES handle datasets cataloged on more than five volume !    */
/*    (So doesn't write out an error message for that condition)      */
/*                                                                    */
/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */
/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */
/*    guess this shouldn't be an issue for many out there.            */
/*                                                                    */
/* 6. It writes its report to the REPORT member of the PDS rather     */
/*    than to a SYSOUT.                                               */
/*                                                                    */
/* 7. It generates a RECAT member that contains statements to allow   */
/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */
/*                                                                    */
/*    Currently this only supports VSAM clusters with the following   */
/*    non-default attributes : LINEAR, REUSE                          */
/*                                                                    */
/* 8. It can be used to compare two catalogs and produces reports     */
/*    showing the differences between the catalogs.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If Address() = 'SH' Then             /* test for UNIX shell environ   */
 sh_flag = 'SH'
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (sh_flag /= 'SH') &,              /* it not UNIX shell             */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say '**(Error-1)* No TSO environment and no UNIX environment.'
  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = ' '                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
rcnvdsn = ''                         /* set dsn to null               */
/**********************************************************************/
/* Handle passed parameters                                           */
/**********************************************************************/
Arg vals                             /* Get passed arguments          */
argnum = 0                           /*                               */
targ_cat = ''                        /* set target catalog to null    */

/* ------------------------------------- *
 | Check for TARGET(newcatalog) keyword: |
 | - not found then done here            |
 | - found then extract                  |
 |   - save target catalog name          |
 |   - remove from parameters            |
 * ------------------------------------- */
if pos("TARGET(",translate(vals)) > 0 then do
   parse value translate(vals) with val_left "TARGET("targ_cat")" val_right
   vals = val_left val_right
   if left(targ_cat,1) = "'" then
      parse value targ_cat with "'"targ_cat"'"
   end

Do i = 1 to Words(vals)              /* loop thru arguments           */
 testarg = Strip(Word(vals,i),B,"'") /* remove inverted commas        */
 Upper testarg                       /* convert to upper case         */
 Select                              /*                               */
  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */
   Do                                /*                               */
    debug = Substr(testarg,7,1)      /* get debug value               */
    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */
   End                               /*                               */
  When (testarg = '?') Then          /*                               */
   Do                                /*                               */
    Say "RCNVTCAT requires either one or two parameters"
    Say " - RCNVTCAT catname       : produces MCNVTCAT type output"
    Say " - RCNVTCAT oldcat newcat : produces catalog comparison output"
    Say " - RCNVTCAT oldcat TARGET(newcat) : produce recatalog output"*/
    Signal FINISH                    /*                               */
   End                               /*                               */
  Otherwise                          /*                               */
   Do                                /*                               */
    argnum = argnum + 1              /*                               */
    cat.argnum = testarg             /*                               */
   End                               /*                               */
 End                                 /*                               */
End                                  /*                               */
Select                               /*                               */
 When (argnum = 0) Then              /*                               */
  Do                                 /*                               */
   Say '**(cat)** No entry provided for catalog name.'
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
 When (argnum = 1) Then              /* only one catalog              */
  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */
 When (argnum = 2) Then              /* two catalogs                  */
  process = 'CATCOMP'                /* process for Catalog compare   */
 Otherwise                           /* two catalogs                  */
  Do                                 /*                               */
   Say '**(cat)** Too many arguments - retry.'
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
End                                  /*                               */
/**********************************************************************/
If (DsExist("'"cat.1"'") > 4) Then /*                               */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for catalog name.'
  Say '**(cat)** 'cat.1
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
If (process = 'CATCOMP') &,        /* Catalog compare processing    */
   (DsExist("'"cat.2"'") > 4) Then /* bad return                    */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for second catalog name.'
  Say '**(cat)** 'cat.2
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
If (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */
 Do                                  /*                               */
  count.id = 0                       /* initialise count              */
  member = 'ALIAS'                   /* processing ALIAS              */
  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'NONVSAM'                 /* processing NONVSAM            */
  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYS1'                    /* processing SYS1               */
  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'IMPORT'                  /* processing IMPORT             */
  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'GDG'                     /* processing GDG                */
  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'MISC'                    /* processing MISC               */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'RECAT'                   /* processing RECAT (MISC+)      */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYSCTLG'                 /* processing SYSCTLG            */
  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'REPORT'                  /* processing REPORT             */
  Call MEM_REPORT                    /* generate report               */
  Call WRITE_MEMBER                  /* write out member              */
 End                                 /*                               */
Else                                 /* Process as Catalog compare    */
 Do                                  /*                               */
  id = 'OLD'                         /* specify for 'old' catalog     */
  count.id = 0                       /* initialise count              */
  cat.old = cat.1                    /* retain catalog name           */
  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */
  id = 'NEW'                         /* specify for 'NEW' catalog     */
  count.id = 0                       /* initialise count              */
  cat.new = cat.2                    /* retain catalog name           */
  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */
  member = 'COMPFULL'                /* processing FULL comparison    */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'COMPSHRT'                /* processing SHORT comparison   */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'EXTRA'                   /* processing EXTRA member       */
  Call NEW_EXT                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'CHANGED'                 /* processing CHANGED member     */
  Call OLD_BAD                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
 End                                 /*                               */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"rcnvdsn"')"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say '**(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say '**(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000E'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('ATTR1   ',8)        /* Attributes                    */
csifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld11 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld12 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13||csifld14
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say '**(Error-1)* CSI processing.'
   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* Work Area defined  = 'csiusrln
   Say '**(Error-2)* Work Area used     = 'csiusdln
   Say '**(Error-3)* Work Area required = 'csireqln
   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say 'off=<'off'>'                /*                               */
    Say 'entry =<'Substr(dwork,off,150)'>'
    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* No data returned'
       Say '**(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
attr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */
cattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */
volser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */
fileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */
vsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ATTR1') > 0) Then    /*                           */
 Call FLD_ATTR1                          /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ATTR1    - Process ATTR1    field                              */
/**********************************************************************/
FLD_ATTR1:                           /* ATTR1    field processing   ##*/
attr1 = X2b(c2x(attr1))              /*                               */
If (Substr(attr1,1,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' SPEED'       /*                               */
If (Substr(attr1,3,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' REUSE'       /*                               */
If (Substr(attr1,4,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' ERASE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
dsn = rcnvdsn
If sh_flag = 'SH' Then
 Do
  Address syscall getlogin sysuid
  random_dsn = 'T'random(9999)
  rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn
  bpxparm = "Alloc ",
            "Da("rcnvdsn")" ,
            "Fi(REPORT) ",
            "Lrecl(133) ",
            "Unit(SYSALLDA)",
            "Space(2,2) ",
            "Dir(10) ",
            "Cyl ",
            "Blksize(1330) ",
            "Recfm(F,B) ",
            "New ",
            "Catalog ",
            "Reuse"
  rc=BPXWDYN(bpxparm)
  If rc <> 0 Then
   Do
    Say '**(Error-1)* Allocation of DD:REPORT Failed.'
    Select
     When rc = 20 Then
      Say '**(Error-2)* BPXWDYN Invalid Parameter List.'
     When rc > 0 | rc <-1610612737 Then
      Do
       hexrc=right(d2x(rc),8,"0")
       Say '**(Error-2)* Dynamic Allocation error code:'hexcode
      End
     When rc <= -21 & rc >= -9999 Then
      Say '**(Error-2)* Error in key number 'abs(rc)-20
     When rc <= -10000 & rc >= -10099 Then
      Say '**(Error-2)* Message processing error. IEFDB476 returned code:',
           abs(rc)-10000
    End
    Signal FINISH
   End
  dsn = rcnvdsn                      /*                               */
  say 'RCNVTCAT Report DSN:' dsn
  Return
 End
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* For execution in batch, please ensure that a PDS'
   Say '**(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say '**(Error-1)* For execution in foreground TSO, please ensure'
    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    random_dsn = 'T'random(9999)
    if sysvar('syspref') = ''
       then rcnvdsn = sysvar('sysuid')'.RCNVTCAT.REPORT.'random_dsn
       else rcnvdsn = sysvar('syspref')'.RCNVTCAT.REPORT.'random_dsn
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Dataset('"rcnvdsn"')" ,
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                 "Da('"rcnvdsn"')" ,
                "Blksize(1330) Recfm(F,B) New Reuse Catalog"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    dsn = rcnvdsn                    /*                               */
   End                               /*                               */
say 'RCNVTCAT Report DSN:' dsn
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
ali_tot = 0                          /* Total Aliases                 */
asy_tot = 0                          /* Total Aliases SYSCATLG        */
anv_tot = 0                          /* Total Aliases NONVSAM         */
axx_tot = 0                          /* interim alias total           */
avu_tot = 0                          /* Total Aliases VSAM UCAT       */
gdg_tot = 0                          /* Total GDGs                    */
ivd_tot = 0                          /* Total invalid devices         */
msc_tot = 0                          /* Total MISC datasets           */
nvd_tot = 0                          /* Total NONVSAM datasets        */
nvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */
nvv_tot = 0                          /* Total NONVSAM dsn volumes     */
syc_tot = 0                          /* Total SYSCTLG datasets        */
sy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */
uct_tot = 0                          /* Total Usercatalog imports     */
Return                               /*                               */
/**********************************************************************/

DsExist: Procedure Expose sysreason sysmsglvl1 sysmsglvl2
parse arg indsn
sysreason=0
sysmsglvl1=' Not Emulated '
sysmsglvl2=' Not Emulated '
If indsn = '' Then
 Do
   sysreason=29
   return 16
 End
xx=outtrap('junk.','*') /* I don't care */
Address TSO "LISTCAT ENT("indsn")"
lrc=rc
sysreason=rc
hexrc=right(d2x(rc),8,"0")
xx=outtrap("OFF")
If "0438" = left(hexrc,4) Then
 Do
  sysreason=24
  Return 16
 End
drop junk.
return lrc
LISTDD:   /* new routine */
rc=bpxwdyn("INFO ",
           "DD(REPORT) ",
           "INRTDSN(rcnvdsn) ",
           "INRDSNT(dsntype) ",
           "INRTORG(dsorg) ",
           "MSG(message.)")
If rc <> 0 Then
 Do
  rcnvdsn=''
  return 16
 End
if dsntype <> "PDS" then return 8
if 'PO' <> left(dsorg,2) then return 8
return 0
/* Old implementation */
 call outtrap 'x.'
 'lista sta'
 call outtrap 'off'

 do i = 1 to x.0
    if left(x.i,1) /= ' ' then iterate
    if word(x.i,1) = 'REPORT' then do
       id = i - 1
       rcnvdsn = word(x.id,1)
       leave
       end
    end
  if rcnvdsn = '' then return 16
  return 0
*/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDDO:                                    /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
                                     /*                               */
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  Say '**(cat)** Processing 'Left('CATALOG',10) csicname
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  If (process = 'CATCOMP') Then      /** Catalog compare code        **/
   Do                                /*                               */
    count.id           = count.id+1  /* increment count               */
    val                = count.id    /* save value                    */
    entname.id.val     = entname     /* store entry name              */
    entype.id.val      = entype      /* store entry type              */
    name.id.val        = name        /* store assoc name              */
    type.id.val        = type        /* store assoc type              */
    pageswap.id.val    = pageswap    /* store pageswap                */
    devices.id.val     = devices     /* store devices                 */
    fils.id.val        = fils        /* store fils                    */
    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */
    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */
    gdglimit.id.val    = gdglimit    /* store gdglimit                */
    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */
    vsam_type.id.val   = vsam_type   /* store vsam_attr               */
    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */
    volsers.id.val     = volsers     /* store volsers by value        */
                                     /** Back reference values       **/
    volsers.id.entname = volsers     /* store volsers by entry name   */
    name.id.entname    = name        /* store name by entry name      */
    val.id.entname     = val         /* store value by entry name     */
   End                               /** End Catalog compare code    **/
  Else                               /*                               */
   Do                                /*                               */
    Select                           /*                               */
     When (member = 'MISC') Then     /* MISC member                   */
      Call MEM_MISC                  /*                               */
     When (member = 'RECAT') Then    /* RECAT member                  */
      Call MEM_RECAT                 /*                               */
     When (member = 'ALIAS') Then    /* ALIAS member                  */
      Call MEM_ALIAS                 /*                               */
     When (member = 'GDG') Then      /* GDG member                    */
      Call MEM_GDG                   /*                               */
     When (member = 'IMPORT') Then   /* IMPORT member                 */
      Call MEM_IMPORT                /*                               */
     When (member = 'NONVSAM') Then  /* NONVSAM member                */
      Do                             /*                               */
       axx_tot = anv_tot             /* set intermim alias total      */
       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */
       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */
       If (Substr(entname,1,4) /= 'SYS1') &,
          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */
        Do                           /*                               */
         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */
         Call MEM_NONVSAM            /*                               */
        End                          /*                               */
       anv_tot = axx_tot             /* set non-vsam aliases total    */
      End                            /*                               */
     When (member = 'SYS1') Then     /* SYS1 member                   */
      Do                             /*                               */
       sy1_tot = sy1_tot + 1         /* increment sys1 total          */
       Call MEM_NONVSAM              /*                               */
      End                            /*                               */
     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */
      Do                             /*                               */
       axx_tot = asy_tot             /* interim = syscatlg aliases    */
       syc_tot = syc_tot + 1         /* increment syscatlg total      */
       Call MEM_NONVSAM              /*                               */
       asy_tot = axx_tot             /* set syscatlg total            */
      End                            /*                               */
     Otherwise NOP                   /*                               */
    End                              /*                               */
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_MISC - Generate MISC member lines                              */
/**********************************************************************/
MEM_MISC:                            /* Generate MISC member lines  ##*/
If (entype = 'CLUSTER') |,
   (entype = 'PAGESPACE') Then
 Do
  msc_tot = msc_tot + 1
  l_cnt = l_cnt + 1
  text = ' /* 'Left(entype' ',15,'-')
  text = text' 'Left(entname,32)'  NOT PROCESSED */'
  l.l_cnt = text
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_RECAT - Generate RECAT member lines                            */
/**********************************************************************/
MEM_RECAT:                           /* Generate RECAT member lines ##*/
If (entype = 'PAGESPACE') Then
 Do
  page_name     = entname
  page_swap     = pageswap
  If (Index(type,'D') /= 0) Then
   data_flag = 'DATA'
  Else
   data_flag = ''
 End
If (entype = 'CLUSTER') Then
 Do
  If (Substr(entname,1,4) /= 'SYS1') Then
   Do
    cluster_name  = entname
    l_cnt = l_cnt + 1
    text = ' /* 'Left(entype' ',15,'-')
    text = text' 'Left(entname,34)' CANNOT RECAT */'
    data_flag = ''
    index_flag = ''
    l.l_cnt = text
   End
  Else
   Do
    cluster_name  = entname
    If (Index(type,'D') /= 0) Then
     data_flag = 'DATA'
    Else
     data_flag = ''
    If (Index(type,'I') /= 0) Then
     index_flag = 'INDEX'
    Else
     index_flag = ''
    cluster_bits  = type
   End
 End
If (entype = 'DATA') &,
   (data_flag = 'DATA') Then
 Select
  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */
   Do
    l_cnt = l_cnt + 1
    text = ' /* 'Left('VVDS ',15,'-')
    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'
    l.l_cnt = text
   End
  When (Index(name,page_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left(page_swap,57)' -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    if targ_cat /= ''
    then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
    else l.l_cnt = '          CAT('Left(cat,44)'        )'
   End
  When (Index(name,cluster_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    If (vsam_attr /= '') Then
     Do
      l_cnt = l_cnt + 1
      l.l_cnt = '          'Left(vsam_attr,57)' -'
     End
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'
    If (index_flag = '') Then
     Do
      l_cnt = l_cnt + 1
      if targ_cat /= ''
      then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
      else l.l_cnt = '          CAT('Left(cat,44)'        )'
     End
   End
  Otherwise
   Say '**(Error--1)* Unexpected condition for :'
   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)
   Say '**(Error--3)* page_name    = 'Strip(page_name,T)
   Say '**(Error--4)* entname      = 'Strip(entname,T)
   Say '**(Error--5)* entype       = 'Strip(entype,T)
   Say '**(Error--6)* name         = 'Strip(name,T)
   Say '**(Error--7)* type         = 'Strip(type,T)
   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)
   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)
   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1
   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2
   Say '**(Error-12)* vsamreus     = 'vsamreus
 End
If (entype = 'INDEX') &,
   (index_flag = 'INDEX') Then
 Do
  l_cnt = l_cnt + 1
  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'
  l_cnt = l_cnt + 1
  if targ_cat /= ''
  then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
  else l.l_cnt = '          CAT('Left(cat,44)'        )'
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_ALIAS - Generate ALIAS member lines                            */
/**********************************************************************/
MEM_ALIAS:                           /* Generate ALIAS member lines ##*/
ali_tot = ali_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '     DEF ALIAS(NAME('entname')  -'
l_cnt = l_cnt + 1
l.l_cnt = '          REL('name'))          -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
else l.l_cnt = '          CAT('Left(cat,44)'         )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_IMPORT - Generate IMPORT member lines                          */
/**********************************************************************/
MEM_IMPORT:                          /* Generate IMPORT member lins ##*/
uct_tot = uct_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '    IMPORT   OBJ( ('entname'  -'
l_cnt = l_cnt + 1
l.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'
l.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_GDG - Generate GDG member lines                                */
/**********************************************************************/
MEM_GDG:                             /* Generate GDG member lines   ##*/
gdg_tot = gdg_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  GDG  (NAME('entname') -'
l_cnt = l_cnt + 1
l.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)
l.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_NONVSAM - Generate NONVSAM member lines                        */
/**********************************************************************/
MEM_NONVSAM:                         /* Generate NONVSAM member lins##*/
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  NVSAM(NAME('entname') -'
If (Words(devices) <= 5) Then        /* < 5 devices for dataset       */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          DEVT( 'Left(devices,47)') -'
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq /= '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'
   End                               /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          VOL(  'Left(volser,47)') )-'
 End                                 /*                               */
Else                                 /* > 5 devices for dataset       */
 Do                                  /*                               */
  item_lead = 'DEVT( '               /* devices header                */
  item_end  = ') -'                  /* devices trailer               */
  item_pad  = ''                     /* no padding                    */
  items = devices                    /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq /= '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    item_lead = 'FSEQN('             /* fileseq header                */
    item_end  = ') -'                /* fileseq trailer               */
    item_pad  = Left('',7)           /* 7 spaces padding              */
    items = fileseq                  /* pass data                     */
    Call PLUS5_HANDLE                /* handle > 5 items              */
   End                               /*                               */
  item_lead = 'VOL(  '               /* volumes header                */
  item_end  = ') ) -'                /* volumes trailer               */
  item_pad  = ''                     /* no padding                    */
  items = volser                     /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
 End                                 /*                               */
l_cnt = l_cnt + 1                    /*                               */
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ASSOC_ENTRY - Process associated entries                           */
/**********************************************************************/
ASSOC_ENTRY:                         /* Process associated entries  ##*/
Do ali = 1 to Words(name)
 If (Substr(type,ali,1) = 'X') Then
  Do
   axx_tot = axx_tot + 1
   l_cnt = l_cnt + 1
   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'
   l_cnt = l_cnt + 1
   l.l_cnt = '          REL('entname'))  -'
   l_cnt = l_cnt + 1
   if targ_cat /= ''
   then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
   else l.l_cnt = '          CAT('Left(cat,44)'         )'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */
/**********************************************************************/
PLUS5_HANDLE:                        /* Handle > 5 fields           ##*/
l_cnt = l_cnt + 1
w_end = Wordindex(items,6)
data = Left(Substr(items,1,w_end-1),47)
l.l_cnt = '          'item_lead||data' -'
Do mult = 6 to Words(items) by 5
 w_sta = Wordindex(items,mult)
 w_end = Wordindex(items,mult+5)
 If (w_end = 0) Then
  item = Substr(items,w_sta)
 Else
  item = Substr(items,w_sta,w_end-w_sta)
 l_cnt = l_cnt + 1
 item_length = 47 - Length(item_pad)
 l.l_cnt = '                '||item_pad||Left(item,item_length)' -'
End
l.l_cnt = Strip(l.l_cnt,T,'-')||item_end
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_REPORT - Generate REPORT member                                */
/**********************************************************************/
MEM_REPORT:                          /* Generate REPORT member      ##*/
r.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'
r.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'
r.3  = ' '
r.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '
r.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '
r.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '
r.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '
r.8  = '                                                        '
r.9  = 'NUMBER OF VSAM USER CATALOGS                            '
r.10 = '                                                        '
r.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '
r.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '
r.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '
r.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '
r.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '
r.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'
r.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '
r.18 = 'ALL OTHER NON VSAM DATA SETS                            '
r.19 = '                                                        '
r.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '
r.21 = '                                                        '
r.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '
r.23 = '                                                        '
r.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '
r.25 = 'DEVICE TYPE. SEE NOTE 3                                 '
r.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '
r.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '
r.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '
tot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot
sta_tot = tot_tot + ali_tot
r.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4
r.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5
r.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6
r.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7
r.8  = '                                          '||r.8
r.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9
r.10 = '                                          '||r.10
r.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11
r.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12
r.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13
r.14 = '                                          '||r.14
r.15 = ' SYSCTLG CONVERTED ........        0      '||r.15
r.16 = '                                          '||r.16
r.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17
r.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18
r.19 = '                                          '||r.19
r.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20
r.21 = '                                          '||r.21
r.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22
r.23 = '------------------------------------      '||r.23
r.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24
r.25 = '                                          '||r.25
r.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26
r.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27
r.28 = '                                          '||r.28
r.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'
r.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '
r.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'
r.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'
r.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'
r.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'
r.32 = r.32||'. BETTER CHECK THE CODE !?!'
r.33 = r.33||'HEY ARE PROCESSED TWICE'
l_cnt = 33
Do loop = 1 to 33
 l.loop = r.loop
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* COMP_REPORT - Produce the Catalog comparison report                */
/**********************************************************************/
COMP_REPORT:                         /* Produce the catalog compare ##*/
l_cnt = 0
Do loop = 1 to count.OLD
 entname = entname.OLD.loop
 entype  = entype.OLD.loop
 name    = name.OLD.loop
 volsers = volsers.OLD.loop
 flag.entname = 'Y'
 If (member = 'COMPFULL') Then
  Do
   disp_ent = entname
   disp_entype = Left(entype,8)
  End
 Else
  Do
   disp_ent = Left(entname,36)
   disp_entype = Left(substr(entype,1,3),4)
  End
 disp_vol = Strip(volsers,B)
 If (Symbol('val.NEW.entname') = 'LIT') Then
  Do
   l_cnt = l_cnt + 1
   Select
    When (entype = 'ALIAS  '  ) Then
     detail = Strip(name.OLD.loop,B)
    When (entype = 'DATA'     ) |,
         (entype = 'INDEX'    ) Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)||' ',
              Strip(vsam_type.OLD.loop,B)||' ',
              Strip(vsam_attr.OLD.loop,B)
    When (entype = 'NONVSAM'  ) |,
         (entype = 'GDG'      ) |,
         (entype = 'UCAT'     ) |,
         (entype = 'PAGESPACE') Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)
    Otherwise NOP
   End
   l.l_cnt = disp_entype||disp_ent' --missing - 'detail
   status.OLD.loop = 'MISSING'
  End
 Else
  Do
   namenew = name.NEW.entname
   volsnew = volsers.NEW.entname
   Select
    When (namenew /= name) Then
     Do
      If (entype = 'ALIAS') Then
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADCAT'
       End
      Else
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##related entries do not match.'
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADENT'
       End
     End
    When (volsnew /= volsers) Then
     Do
      l_cnt = l_cnt + 1
      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)
      l.l_cnt = disp_entype||disp_ent||err_text
      status.OLD.loop = 'BADVOL'
     End
    Otherwise
     l_cnt = l_cnt + 1
     l.l_cnt = disp_entype||disp_ent' **entry matches.'
     status.OLD.loop = 'OK'
   End
  End
End
Do loop = 1 to count.NEW
 entname = entname.NEW.loop
 entype  = entype.NEW.loop
 volsers = volsers.NEW.loop
 If (flag.entname /= 'Y') Then
  Do
   If (member = 'COMPFULL') Then
    Do
     disp_ent = entname
     disp_entype = Left(entype,8)
    End
   Else
    Do
     disp_ent = Left(entname,36)
     disp_entype = Left(substr(entype,1,3),4)
    End
   disp_vol = Strip(volsers,B)
   l_cnt = l_cnt + 1
   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol
   status.NEW.loop = 'NEW'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* NEW_EXT - Process for new entries                                  */
/**********************************************************************/
NEW_EXT:                             /* Process new entries         ##*/
Do loop = 1 to count.NEW             /*                               */
 If (status.NEW.loop = 'NEW') Then   /*                               */
  Do                                 /*                               */
   entname = entname.NEW.loop        /*                               */
   entype  = entype.NEW.loop         /*                               */
   If (entype = 'DATA') |,           /*                               */
      (entype = 'INDEX') Then        /*                               */
    Iterate                          /*                               */
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry not present in catalog "cat.old". */"
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry present in catalog     "cat.new". */"
   Call ENTRY_DEL                    /* process an entry delete       */
  End                                /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* OLD_BAD - Process for old entries                                  */
/**********************************************************************/
OLD_BAD:                             /* Process old entries         ##*/
Do loop = 1 to count.OLD             /*                               */
 entname   = entname.OLD.loop        /*                               */
 entype    = entype.OLD.loop         /*                               */
 volsers   = volsers.OLD.loop        /*                               */
 volser    = Strip(volsers,B)        /*                               */
 name      = name.OLD.loop           /*                               */
 type      = type.OLD.loop           /*                               */
 pageswap  = pageswap.OLD.loop       /*                               */
 devices   = devices.OLD.loop        /*                               */
 fils      = fils.OLD.loop           /*                               */
 gdg_emp   = gdg_emp.OLD.loop        /*                               */
 gdg_scr   = gdg_scr.OLD.loop        /*                               */
 gdglimit  = gdglimit.OLD.loop       /*                               */
 vsam_attr = vsam_attr.OLD.loop      /*                               */
 vsam_type = vsam_type.OLD.loop      /*                               */
 vsam_vvds = vsam_vvds.OLD.loop      /*                               */
 namenew   = name.NEW.entname        /*                               */
 volsnew   = volsers.NEW.entname     /*                               */
 If (entype = 'DATA') |,             /*                               */
    (entype = 'INDEX') Then          /*                               */
  Iterate                            /*                               */
 Select                              /*                               */
  When (status.OLD.loop = 'MISSING') Then /*                          */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Entry missing in catalog "cat". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADCAT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Alias incorrectly pointing to "namenew". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADENT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Related entries do not match */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* entry "Strip(entname,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* old "Strip(name,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* new "Strip(namenew,T)" */"
   End                               /*                               */
  When (status.OLD.loop = 'BADVOL') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Volume incorrect - was "volsnew". */"
   End                               /*                               */
  Otherwise Iterate                  /*                               */
 End                                 /*                               */
 Call ENTRY_DEL                      /* process an entry delete       */
 Call ENTRY_CHG                      /* process an entry change       */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_DEL - Create a DELETE statement                              */
/**********************************************************************/
ENTRY_DEL:                           /* Create an entry DELETE      ##*/
If (entype = 'NONVSAM') Then         /*                               */
 tparm = ''                          /*                               */
Else                                 /*                               */
 tparm = entype                      /*                               */
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      DELETE "Strip(entname,T)" "tparm" NOSCRATCH -"
l_cnt = l_cnt + 1                    /*                               */
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
l.l_cnt = "             CAT("Left(cat,44)"         )"
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      SET MAXCC=0"
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_CHG - Create a changed entry statement                       */
/**********************************************************************/
ENTRY_CHG:                           /* Create a changed entry      ##*/
Select                               /*                               */
 When (entype = 'NONVSAM') Then      /*                               */
  Call MEM_NONVSAM                   /*                               */
 When (entype = 'ALIAS') Then        /*                               */
  Call MEM_ALIAS                     /*                               */
 When (entype = 'GDG') Then          /*                               */
  Call MEM_GDG                       /*                               */
 Otherwise NOP                       /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

