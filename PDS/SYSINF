/* REXX - SYSINF : Displays sundry IPL info. etc.                     */
/**********************************************************************/
/* SYSINF - Gets a variety of system and user information.            */
/*                                                                    */
/* Based on an original Gray/Eastoe production in REXXOVISION called  */
/* IPLINF and sundry other sources - especially reading the data area */
/* manuals.                                                           */
/*                                                                    */
/* Changes :                                                          */
/* 03/11/1995 - AJG - Initial version (with added RichE power !)      */
/* 14/06/1996 - AJG - First full rewrite                              */
/* 19/05/1999 - AJG - Updated with various new bits                   */
/* 08/10/1999 - AJG - Added SWAREQ from Gilbert Saint-Flour           */
/* 25/10/1999 - AJG - Added PRSM logical partition number             */
/* 27/10/1999 - AJG - Added HID information                           */
/* 04/01/2000 - AJG - Added user region size                          */
/* 05/01/2000 - AJG - Imbedded the required panel                     */
/* 07/01/2000 - AJG - Added Newstack/Delstack                         */
/* 07/02/2000 - AJG - Allowed for multiple PARMLIBs                   */
/* 07/02/2000 - AJG - Added Master JCL query/display                  */
/* 06/05/2000 - AJG - other way for JOBNAME added                     */
/* 18/07/2000 - AJG - Added performance/charging details              */
/* 09/10/2001 - AJG - Added TCP/IP details                            */
/* 17/10/2001 - AJG - Updated IPL time calculation and added UPTIME   */
/* 18/10/2001 - AJG - Changed leap year calculation                   */
/* 01/11/2001 - AJG - Added '()' removal for master JCL parm          */
/* 09/01/2002 - AJG - Corrected elapsed time since IPL leapyear calc  */
/* 28/02/2002 - AJG - Changed to a new dynamically built panel        */
/* 01/03/2002 - AJG - Added a few new bits                            */
/* 05/03/2002 - AJG - Added IEASYS parm details                       */
/* 13/03/2002 - AJG - Added RACF group details                        */
/* 15/03/2002 - AJG - Display if a group is revoked                   */
/* 19/03/2002 - AJG - Change RACF groups to 5 per line                */
/* 26/03/2002 - AJG - Added susbsystem command prefixes               */
/* 27/03/2002 - AJG - Changed to procedures and tidied ipl/uptime     */
/* 05/04/2002 - AJG - Corrected JES name                              */
/* 12/04/2002 - AJG - Fixed the problem with the &env in master JCL   */
/* 07/05/2002 - AJG - Added logon command                             */
/* 22/05/2002 - AJG - Added HSA enquiry section                       */
/* 12/07/2002 - AJG - Added user storage detail                       */
/* 17/02/2003 - AJG - Added JES variation by MVS fmid                 */
/*                                                                    */
/**********************************************************************/
Numeric Digits 25
/**********************************************************************/
/* Obtain information                                                 */
/**********************************************************************/
Call PROC_ADDR                              /* Address space info     */
Call PROC_USER                              /* RACF user details      */
Call PROC_ACCOUNT                           /* account detail         */
Call PROC_REGION                            /* region detail          */
Call PROC_JOB                               /* job detail             */
Call PROC_MCAT                              /* mastercat detail       */
Call PROC_IEASYS                            /* IEASYSxx details       */
Call PROC_RACF                              /* RACF details           */
Call PROC_IPLTIMES                          /* IPL time details       */
Call PROC_IPL                               /* IPL details            */
Call PROC_IODF                              /* IODF details           */
Call PROC_HARD                              /* hardware details       */
Call PROC_OS                                /* OS Details             */
Call PROC_PAGE                              /* Page details           */
Call PROC_STOR                              /* storage details        */
Call PROC_SYMBOL                            /* static symbols         */
Call PROC_JES                               /* JES details            */
Call PROC_CPU                               /* CPU details            */
Call PROC_HSA                               /* HSA details            */
Call PROC_VERSION                           /* version details        */
Call PROC_TCPIP                             /* TCPIP details          */
Call PROC_OMVS                              /* OMVS details           */
Call PROC_PERFORM                           /* performance details    */
Call PROC_SUBSYS_PREFIX                     /* subsystem prefixes     */
/**********************************************************************/
/* display information                                                */
/**********************************************************************/
Call DEFINE_PANEL                           /* define the panel       */
Call CREATE_MEMBER                          /* create the panel member*/
Address ISPEXEC "LibDef ISPPLIB Library Id("fil") Stack"
Address ISPEXEC "Display Panel(SYSINFO)"    /* display the panel      */
Address ISPEXEC "LibDef ISPPLIB"            /* clear the temp alloc   */
Address TSO     "Free Fi("fil")"            /* free the temp dsn      */
/**********************************************************************/
FINISH:                                     /*                        */
Exit 0                                      /*                        */
/**********************************************************************/
/* Address space info                                                 */
/**********************************************************************/
PROC_ADDR:                                  /* Address space info   ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtasvt  = Storage(D2x(C2d(cvt)+556),4)     /* get the ASVT address   */
asvtmaxu = Storage(D2x(C2d(cvtasvt)+516),4) /* get max Address spaces */
asvtaav  = Storage(D2x(C2d(cvtasvt)+480),4) /* get free Address spaces*/
asvtast  = Storage(D2x(C2d(cvtasvt)+484),4) /* free slots SASI queue  */
asvtanr  = Storage(D2x(C2d(cvtasvt)+488),4) /* free slots NONR queue  */
asvtstrt = Storage(D2x(C2d(cvtasvt)+492),4) /* orig slots SASI queue  */
asvtnonr = Storage(D2x(C2d(cvtasvt)+496),4) /* orig slots NONR queue  */
offset   = 528                              /*                        */
nonremk  = C2d(cvtasvt)+(C2d('80000000'x)+528) /*                     */
duffcnt  = 0                                /* init non-reus count    */
okcnt    = 0                                /* init in-use count      */
Do loop = 1 To C2d(asvtmaxu)                /*                        */
 ascbadd  = Storage(D2x(C2d(cvtasvt)+offset),4) /*                    */
 If (C2d(ascbadd) = nonremk) Then           /*                        */
  duffcnt = duffcnt + 1                     /*                        */
 ascbascb = Storage(D2x(C2d(ascbadd)+0),4)  /*                        */
 If (ascbascb = 'ASCB') Then                /*                        */
  okcnt = okcnt + 1                         /*                        */
 offset = offset + 4                        /*                        */
End                                         /*                        */
asvtmaxu = C2d(asvtmaxu)                    /* maximum address spaces */
asvtaav  = C2d(asvtaav)                     /* free address spaces    */
asvtast  = C2d(asvtast)                     /* free slots SASI queue  */
asvtanr  = C2d(asvtanr)                     /* free slots NONR queue  */
asvtstrt = C2d(asvtstrt)                    /* orig slots SASI queue  */
asvtnonr = C2d(asvtnonr)                    /* orig slots NONR queue  */
Return                                      /*                        */
/**********************************************************************/
/* racf info                                                          */
/**********************************************************************/
PROC_USER:                                  /* RACF user details    ##*/
psaold   = Storage(224,4)                   /* get the ASCB address   */
ascbasxb = Storage(D2x(C2d(psaold)+108),4)  /* get the ASXB address   */
asxbsenv = Storage(D2x(C2d(ascbasxb)+200),4)/*                        */
asxblwa  = Storage(D2x(C2d(ascbasxb)+20),4) /* pointer to the LWA     */
lwalgcmd = Storage(D2x(C2d(asxblwa)+186),80)/* get command line       */
lwaacct  = Storage(D2x(C2d(asxblwa)+400),40)/* get account field      */
aceegrpn = Storage(D2x(C2d(asxbsenv)+30),8) /* get the connect group  */
aceeflg1 = Storage(D2x(C2d(asxbsenv)+38),1) /*                        */
bits = x2b(C2x(aceeflg1))                   /*                        */
racfacc  = ''                               /*                        */
If (Substr(bits,1,1) = '1') Then            /*                        */
 racfacc = racfacc||'Special '              /*                        */
If (Substr(bits,3,1) = '1') Then            /*                        */
 racfacc = racfacc||'Operations '           /*                        */
If (Substr(bits,4,1) = '1') Then            /*                        */
 racfacc = racfacc||'AudiTor'               /*                        */
If (racfacc = '') Then                      /*                        */
 racfacc = 'None'                           /*                        */
aceetrid = Storage(D2x(C2d(asxbsenv)+64),8) /* get the terminal ID    */
aceeunam = Storage(D2x(C2d(asxbsenv)+100),4)/* get the username addr  */
username = Storage(D2x(C2d(aceeunam)+1),20) /* get the username       */
aceefcgp = Storage(D2x(C2d(asxbsenv)+116),4)/* get the group list add */
cgrplen  = Storage(D2x(C2d(aceefcgp)+5),3)  /* get the list length    */
cgrplen  = C2d(cgrplen)                     /*                        */
cgrpnum  = Storage(D2x(C2d(aceefcgp)+8),2)  /* get the list count     */
cgrpnum  = C2d(cgrpnum)                     /*                        */
cgrp     = Storage(D2x(C2d(aceefcgp)+32),(cgrplen-32)) /* get groups  */
grp_cnt = 0                                 /* initialise variable    */
Do loop = 1 to cgrplen by 24                /* loop thru groups       */
 group = Substr(cgrp,loop,24)
 group = Strip(Substr(cgrp,loop,8))         /* extract the group name */
 If (group = 'FFFFFFFFFFFFFFFF'x) Then      /* revoked                */
  group = '*REVOKED*'                       /* set revoked flag       */
 If (group /= '') Then                      /* blank                  */
  Do                                        /*                        */
   grp_cnt = grp_cnt + 1                    /* increment count        */
   group.grp_cnt = group                    /* save group name        */
  End                                       /*                        */
End                                         /*                        */
Return                                      /*                        */
/**********************************************************************/
/* get tso account code routine                                       */
/**********************************************************************/
PROC_ACCOUNT:                               /* account detail       ##*/
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbjscbb = Storage(D2x(C2d(psatold)+181),3) /* pointer to jscb        */
jscbjcta = Storage(D2x(C2d(tcbjscbb)+261),3) /* pointer to the JCT    */
jscbjcta = SWAREQ(jscbjcta)                 /*                        */
jobname  = Storage(D2x(C2d(jscbjcta)+8),8)  /* get the jobname        */
jobname  = MvsVar('SYMDEF','JOBNAME')       /* get the jobname        */
jctactad = Storage(D2x(C2d(jscbjcta)+40),3) /* pointer to act         */
jctactad = SWAREQ(jctactad)                 /*                        */
acct#l   = Storage(D2x(C2d(jctactad)+32),1) /* length of account      */
acct#    = Storage(D2x(C2d(jctactad)+33),C2d(acct#l)) /* account id   */
acctnum  = Strip(acct#,b)                   /* tidy up account number */
Return                                      /*                        */
/**********************************************************************/
/* get requested region size                                          */
/**********************************************************************/
PROC_REGION:                                /* region detail        ##*/
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbjscbb = Storage(D2x(C2d(psatold)+181),3) /* pointer to jscb        */
jscsctp  = Storage(D2x(C2d(tcbjscbb)+329),3) /* pointer to the SCT    */
jscsctp = SWAREQ(jscsctp)                   /*                        */
sctpgmnm = Storage(D2x(C2d(jscsctp)+108),8) /* get the program name   */
sctrgsz  = Storage(D2x(C2d(jscsctp)+173),3) /* get the region size    */
region   = C2d(sctrgsz)||'K'                /* convert to K bytes     */
Return                                      /*                        */
/**********************************************************************/
/* job information                                                    */
/**********************************************************************/
PROC_JOB:                                   /* job detail           ##*/
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbjscb  = Storage(D2x(C2d(psatold)+180),4) /* pointer to jscb        */
jscbssib = Storage(D2x(C2d(tcbjscb)+316),4) /* pointer to ssib        */
ssibjbid = Storage(D2x(C2d(jscbssib)+12),8) /* get the jobid          */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
tiocnjob = Storage(D2x(C2d(tcbtio)+0),8)    /* pointer to jobname     */
tiocstep = Storage(D2x(C2d(tcbtio)+8),8)    /* pointer to stepname    */
tiocjstn = Storage(D2x(C2d(tcbtio)+16),8)   /* pointer to proc jobstep*/
Return
/* This section isn't required for SYSINF, just here in case I need it*/
ddentry  = Storage(D2x(C2d(tcbtio)+24),8192) /* DD information -get 8K*/
ddpos    = 1                                /* start position         */
tioelngh = C2d(Substr(ddentry,ddpos,1))     /* length of DD entry     */
Do While tioelngh > 0                       /* loop thru until last   */
 tioeddnm = Substr(ddentry,ddpos+4,8)       /* get ddname             */
 tioejfcb = Substr(ddentry,ddpos+12,3)      /* get jfcb address       */
 tioejfcb = SWAREQ(tioejfcb)                /*                        */
 jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44)/* get dataset name       */
 ddpos    = ddpos + tioelngh                /* update to next dd entry*/
 tioelngh = C2d(Substr(ddentry,ddpos,1))    /* get new length         */
End                                         /*                        */
Return                                      /*                        */
/**********************************************************************/
/* master cat info                                                    */
/**********************************************************************/
PROC_MCAT:                                  /* mastercat detail     ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */
mvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */
If (Substr(mvsfmid,4,4) <= 6609) Then       /* CAXWA avail B4 R10     */
 Do                                         /*                        */
  cvtcbsp  = Storage(D2x(C2d(cvt)+256),4)   /* get the AMCBS address  */
  acb      = Storage(D2x(C2d(cvtcbsp)+8),4) /* get the acb Address    */
  caxwa    = Storage(D2x(C2d(acb)+64),4)    /* get the caxwa Address  */
  dsncat   = Storage(D2x(C2d(caxwa)+52),44) /* dsn of master cat      */
  dsncat   = Strip(dsncat,T)                /*                        */
  ucbcat   = Storage(D2x(C2d(caxwa)+28),4)  /* ucb name for master cat*/
  volcat   = Storage(D2x(C2d(ucbcat)+28),6) /* volume for master cat  */
 End                                        /*                        */
Else                                        /* OS/390 R10 and above   */
 Do                                         /*                        */
  cvtecvt  = Storage(D2x(C2d(cvt)+140),4)   /* get the ECVT address   */
  ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4)/* get the ihaipa Address*/
  ipascat  = Storage(D2x(C2d(ecvtipa)+224),63) /* get the mcat details*/
  dsncat   = Strip(Substr(ipascat,11,44))   /* master catalog dsn     */
  volcat   = Substr(ipascat,1,6)            /* master catalog VOLSER  */
 End                                        /*                        */
Return                                      /*                        */
/**********************************************************************/
/* IEASYSxx paramemter details                                        */
/*  additional pointers - thanks to Mark Zelden [mzelden@FLASH.NET]   */
/**********************************************************************/
PROC_IEASYS:                                /* IEASYSxx details     ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */
mvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */
pr =   'ALLOC   APF   APG      BLDL    BLDLF   CLOCK   CLPA    CMB '
pr = pr'CMD     CON   CONT     COUPLE  CPQE    CSA     CSCBLOC CVIO '
pr = pr'DEVSUP  DIAG  DUMP     DUPLEX  EXIT    FIX     GRS     GRSCNF '
pr = pr'GRSRNL  ICS   IOS      IPS     LNK     LNKAUTH LOGCLS  LOGLMT '
pr = pr'LOGREC  LPA   MAXCAD   MAXUSER MLPA    MSTRJCL NONVIO  NSYSLX '
pr = pr'NUCMAP  '
If (Substr(mvsfmid,4,4) >= 6603) Then       /*                        */
 pr = pr'OMVS    '
Else
 pr = pr'RESERVED'
pr = pr'OPI     OPT   PAGE-OPR PAGE    PAGNUM  PAGTOTL PAK     PLEXCFG '
pr = pr'PROD    PROG  PURGE    RDE     REAL    RER     RSU     RSVNONR '
pr = pr'RSVSTRT SCH   SMF      SMS     SQA     SSN     SVC     SWAP    '
pr = pr'SYSNAME SYSP  VAL      VIODSN  VRREGN'
If (Substr(mvsfmid,4,4) >= 6604) Then       /*                        */
 pr = pr'RTLS    '
If (Substr(mvsfmid,4,4) >= 6602) Then       /* IHAIPA avail after R2  */
 Do                                         /*                        */
  cvtecvt  = Storage(D2x(C2d(cvt)+140),4)   /* get the ECVT address   */
  ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4)/* get the ihaipa Address*/
  ipaplnum = Storage(D2x(C2d(ecvtipa)+2148),2) /* number of parms     */
  ipasys   = Storage(D2x(C2d(ecvtipa)+2152),640) /*                   */
  para_cnt = 0                              /*                        */
  Do loop = 1 to 80                         /*                        */
   parm_no = (loop * 8) - 7
   ipapdes = Substr(ipasys,parm_no,8)       /*                        */
   ipapdesa = Substr(ipapdes,1,4)           /*                        */
   ipapdesl = Substr(ipapdes,5,2)           /*                        */
   ipapdess = Substr(ipapdes,7,2)           /*                        */
   ipapdedo = Substr(ipapdes,7,2)           /*                        */
   If (C2d(ipapdesl) > 0) Then
    Do
     para_cnt = para_cnt + 1
     parm.para_cnt = Storage(D2x(C2d(ipapdesa)),C2d(ipapdesl))
     parm_nm.para_cnt = Word(pr,loop)
     Select
      When (C2x(ipapdedo) = '0000') Then parm_ty.para_cnt = 'Default '
      When (C2x(ipapdedo) = 'FFFF') Then parm_ty.para_cnt = 'Operator'
      Otherwise parm_ty.para_cnt = 'IEASYS'ipapdess
     End
    End
  End                                       /*                        */
 End                                        /*                        */
Return                                      /*                        */
/**********************************************************************/
/* racf information                                                   */
/**********************************************************************/
PROC_RACF:                                  /* RACF details         ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtrac   = Storage(D2x(C2d(cvt)+992),4)     /* get the RCVT address   */
rcvtvrmn = Storage(D2x(C2d(cvtrac)+616),4)  /* get the RACF version   */
dsnrac   = ''                               /* reset racf dsn         */
volrac   = ''                               /* reset racf volume name */
If (C2d(cvtrac) /= 0) Then                  /* If the rcvt is not 0   */
 Do                                         /*                        */
  dsnrac = Storage(D2x(C2d(cvtrac)+56),44)  /* get the racf dsn       */
  dsnrac = Strip(dsnrac,t)                  /*                        */
  ucbrac = Storage(D2x(C2d(cvtrac)+36),4)   /* get the racf ucb name  */
  volrac = Storage(D2x(C2d(ucbrac)+28),6)   /* get the racf volume    */
  rcvtidc = Storage(D2x(C2d(cvtrac)+0),4)   /* get the security type  */
  If (rcvtidc = 'RCVT') Then sectype = 'RACF' /*                      */
  If (rcvtidc = 'RTSS') Then sectype = 'TopSecret' /*                 */
  If (rcvtidc = 'ACF2') Then sectype = 'ACF2' /*                      */
 End                                        /*                        */
racf = Sysvar('sysracf')                    /*                        */
racflev = Sysvar('syslracf')                /*                        */
Return                                      /*                        */
/**********************************************************************/
/* IPL time info                                                      */
/**********************************************************************/
PROC_IPLTIMES:                              /* IPL time details     ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtsmca  = Storage(D2x(C2d(cvt)+196),4)     /* get the SMCA address   */
smcaitme = Storage(D2x(C2d(cvtsmca)+336),4) /* get the smca ipl time  */
smcaidte = Storage(D2x(C2d(cvtsmca)+340),4) /* get the smca ipl date  */
smcasid  = Storage(D2x(C2d(cvtsmca)+16),4)  /* get the smca SID       */
iplsecs  = C2d(smcaitme) % 100              /* get IPL time in seconds*/
iplhr    = Right(iplsecs % 3600 ,2,'0')     /* get IPL hour           */
iplmin   = Right((iplsecs%60)-(iplhr*60),2,'0') /* get IPL minute     */
iplsec   = Right(iplsecs // 60 ,2,'0')      /* get IPL seconds        */
iplcent  = Substr(C2x(smcaidte),1,2)        /* get IPL century        */
iplyr    = Substr(C2x(smcaidte),3,2)        /* get IPL year           */
ipldy    = Substr(C2x(smcaidte),5,3)        /* get IPL day            */
If (iplcent = '01') Then iplyr = '20'iplyr  /* decode century indicat */
If (iplcent = '00') Then iplyr = '19'iplyr  /* decode century indicat */
x = (iplyr/4=0) - (iplyr//100=0) + (iplyr//400=0) /* test leapyear    */
dd = ipldy                                  /*                        */
If (dd > (59 + x)) Then                     /* convert to gregorian   */
 dd = dd+2-x                                /* "                      */
mm = (((dd+91)*100)%3055)                   /* "                      */
dd = dd+91-(mm*3055)%100                    /* "                      */
mm = mm - 2                                 /* "                      */
dd = Right(dd,2,'0')                        /*                        */
mm = Right(mm,2,'0')                        /*                        */
ipljul   = iplyr||"."||ipldy                /*                        */
iplgrg   = "("||dd||"/"||mm||"/"||iplyr||")"/*                        */
ipltim   = iplhr||":"||iplmin||":"||iplsec  /*                        */
ipldates = ipljul||' '||iplgrg||' '||ipltim /*                        */
curyr    = Substr(Date('S'),1,4)            /* get current year       */
curdy    = Substr(Date('J'),3,3)            /* get current day        */
cursecs  = Time('S')                        /* get cur time in seconds*/
curjul   = curyr||"."||curdy                /* get current julian     */
curgrg   = "("||Substr(Date('E'),1,6)||curyr||")" /* current gregorian*/
curtim   = Time()                           /* current time           */
curdates = curjul||' '||curgrg||' '||curtim /* build for display      */
offdays  = 0                                /* initialise offdays     */
If (iplsecs < cursecs) Then                 /* if ipl less than cur   */
 offsecs = cursecs - iplsecs                /*  offset is cur - ipl   */
Else                                        /* otherwise              */
 Do                                         /*                        */
  offsecs = (cursecs + 86400) - iplsecs     /*  offset is cur+day-ipl */
  offdays = offdays - 1                     /*  offdays is one less   */
 End                                        /*                        */
offhr   = Right(offsecs % 3600 ,2,'0')      /* get offset hours       */
offmin  = Right((offsecs%60)-(offhr*60),2,'0') /* get offset minute   */
offsec  = Right(offsecs // 60 ,2,'0')       /* get offset seconds     */
If (iplyr = curyr) Then                     /* if same year           */
 offdays = offdays + (curdy - ipldy)        /*  offset days cur - ipl */
Else                                        /* otherwise              */
 Do                                         /*                        */
  Do year = iplyr To (curyr - 1) By 1       /* loop years             */
   x = (year//4=0) - (year//100=0) + (year//400=0) /* test leapyear   */
   If (x = 0) Then offdays = offdays + 365  /*  mod for normal year   */
              Else offdays = offdays + 366  /*  mod for leap year     */
  End                                       /*                        */
  offdays = (curdy + offdays) - ipldy       /* get offset days        */
 End                                        /*                        */
offdates = offdays' days(s) 'offhr' hours(s) 'offmin' minute(s) 'offsec
offdates = offdates||' seconds(s)'
Return                                      /*                        */
/**********************************************************************/
/* other ipl info                                                     */
/**********************************************************************/
PROC_IPL:                                   /* IPL details          ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtsysad = Storage(D2x(C2d(cvt)+48),4)      /* get the SYSAD address  */
cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */
cvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */
sysres   = Storage(D2x(C2d(cvtsysad)+28),6) /* get the sysres volser  */
sysuad   = Storage(D2x(C2d(cvtsysad)+13),3) /* get the sysres UCBname */
syschan  = Storage(D2x(C2d(cvtsysad)+4),2)  /* get the sysres dev no  */
If (sysuad = 'UCB') Then sysuad = C2x(syschan) /* four char UCBs      */
ecvtload = Storage(D2x(C2d(cvtecvt)+160),8) /*                        */
ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address */
ipalparm = Storage(D2x(C2d(ecvtipa)+16),8)  /* get the loadparm       */
ipalpdsn = Storage(D2x(C2d(ecvtipa)+48),44) /* get the loadxx dataset */
ipalpdsn = Strip(ipalpdsn,b)||'(LOAD'||Substr(ipalparm,5,2)||')' /*   */
ipasplst = Storage(D2x(C2d(ecvtipa)+160),63)/* get the ieasysxx sufx  */
If (Substr(ipasplst,1,1) = '(') Then        /*                        */
 pref = Substr(ipasplst,2,2)                /*                        */
Else                                        /*                        */
 pref = Substr(ipasplst,1,2)                /*                        */
parm_cnt = 0                                /*                        */
ipaplnumx= Storage(D2x(C2d(ecvtipa)+2134),2)/* get the parmlib count  */
ipaplnumx = C2d(ipaplnumx)                  /*                        */
If (ipaplnumx = 0) Then ipaplnumx = 10      /* set if pre R10         */
Do loop = 0 to ipaplnumx                    /* loop for parmlibs      */
 ipaplib = Storage(D2x(c2d(ecvtipa)+416+(loop*64)),64) /*             */
 ipapldsn = Substr(ipaplib,1,44)            /* parmlib dsname         */
 ipaplvol = Substr(ipaplib,46,6)            /* parmlib volume         */
 ipaplflg = X2b(C2x(Substr(ipaplib,64,1)))  /* parmlib flags          */
 If (Strip(ipapldsn,B) = '') Then Iterate   /*                        */
 parm_cnt = parm_cnt + 1                    /*                        */
 parmlib.parm_cnt = ipapldsn                /*                        */
 parmlin.parm_cnt = Left(ipapldsn,45)||Left(ipaplvol,7)
End                                         /*                        */
ipapldsn = parmlib.1                        /* get the primary parmlib*/
ipapldsn = Strip(ipapldsn,b)||'(IEASYS'||pref||')' /*                 */
ipalpnam = Storage(D2x(C2d(ecvtipa)+32),8)  /* get the lpar name      */
ipahwnam = Storage(D2x(C2d(ecvtipa)+40),8)  /* get the hardware name  */
ipavmnam = Storage(D2x(C2d(ecvtipa)+48),8)  /* get the vmuserid name  */
/**********************************************************************/
ipamstrj = Storage(D2x(C2d(ecvtipa)+2448),8)/* get master jcl PDE     */
ipapdesa = Substr(ipamstrj,1,4)             /* get master jcl address */
ipapdesl = Substr(ipamstrj,5,2)             /* get master jcl length  */
mstrjcl  = Storage(D2x(c2d(ipapdesa)),C2d(ipapdesl)) /* mstrjcl parm  */
mstrjcl = Strip(Strip(mstrjcl,B,')'),B,'(') /* strip brackets         */
Do loop = 1 to parm_cnt
 parmlib = Strip(parmlib.loop,B)
 If (Sysdsn("'"parmlib"(MSTJCL"mstrjcl")'") = 'OK') Then Leave
End
mstrjcl = parmlib||"(MSTJCL"||mstrjcl||")"
Address TSO
"Alloc Fi(MJCLIN) Da('"mstrjcl"') Shr Reu"
"ExecIO * DiskR MJCLIN (Finis Stem mjcl)"
"Free Fi(MJCLIN)"
Return                                      /*                        */
/**********************************************************************/
/* IODF information                                                   */
/**********************************************************************/
PROC_IODF:                                  /* IODF details         ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtixavl = Storage(D2x(C2d(cvt)+124),4)     /* get the IOCOM address  */
cvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */
cvtiocid = Storage(D2x(C2d(cvtext2)+6),2)   /* active IO config id    */
iociovtp = Storage(D2x(C2d(cvtixavl)+208),4)/* get the IOVT address   */
cda      = Storage(D2x(C2d(iociovtp)+24),4) /* get the CDA address    */
iodfname = Storage(D2x(c2d(cda)+32),44)     /* get the IODF name      */
iodfcfgi = Storage(D2x(c2d(cda)+92),8)      /* get the IODF config id */
iodfedt  = Storage(D2x(c2d(cda)+104),2)     /* get the IODF EDT       */
iodfproc = Storage(D2x(c2d(cda)+124),8)     /* get the IODF Proc      */
iodfdate = Storage(D2x(c2d(cda)+156),8)     /* get the IODF Date      */
iodftime = Storage(D2x(c2d(cda)+164),8)     /* get the IODF Time      */
iodfdesc = Storage(D2x(c2d(cda)+172),16)    /* get the IODF Descriptn */
Return                                      /*                        */
/**********************************************************************/
/* System Host ID information                                         */
/* Central Processing Complex Node Descriptor fields                  */
/**********************************************************************/
PROC_HARD:                                  /* hardware details     ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvthid   = Storage(D2x(C2d(cvt)+1068),4)    /* get the IOSDSHID addr  */
flags  = Storage(D2x(C2d(cvthid)+22),1)     /* cpcnd_flags            */
If (flags /= x'40') Then                    /* test valid node descrip*/
 Do                                         /*                        */
  type  = Storage(D2x(C2d(cvthid)+26),6)    /* cpcnd_type             */
  model = Storage(D2x(C2d(cvthid)+32),3)    /* cpcnd_model            */
  man   = Storage(D2x(C2d(cvthid)+35),3)    /* cpcnd_man              */
  plant = Storage(D2x(C2d(cvthid)+38),2)    /* cpcnd_plant            */
  seqno = Storage(D2x(C2d(cvthid)+40),12)   /* cpcnd_seqno            */
 End                                        /*                        */
Else                                        /* invalid node descriptor*/
 Do                                         /*                        */
  type  = ''                                /*                        */
  model = ''                                /*                        */
  man   = ''                                /*                        */
  plant = ''                                /*                        */
  seqno = ''                                /*                        */
 End                                        /*                        */
Return                                      /*                        */
/**********************************************************************/
/* os/mvs information                                                 */
/**********************************************************************/
PROC_OS:                                    /* OS Details           ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */
cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */
cvtcsd   = Storage(D2x(C2d(cvt)+660),4)     /* get the CSD address    */
ecvtsplx = Storage(D2x(C2d(cvtecvt)+8),8)   /* sysplex name           */
ecvthdnm = Storage(D2x(C2d(cvtecvt)+336),8) /* hardware name          */
ecvtlpnm = Storage(D2x(C2d(cvtecvt)+344),8) /* lpar name              */
ecvtvmnm = Storage(D2x(C2d(cvtecvt)+352),8) /* vmuserid name          */
ecvtpown = Storage(D2x(C2d(cvtecvt)+480),16)/* product owner          */
ecvtpnam = Storage(D2x(C2d(cvtecvt)+496),16)/* product name           */
ecvtpver = Storage(D2x(C2d(cvtecvt)+512),2) /* product version        */
ecvtprel = Storage(D2x(C2d(cvtecvt)+514),2) /* product release        */
ecvtpmod = Storage(D2x(C2d(cvtecvt)+516),2) /* product mod level      */
mvsver   = Substr(cvtpfx,1,7)               /* get the mvs version    */
mvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */
ecvtclon = Storage(D2x(C2d(cvtecvt)+264),2) /* sysplex identIfier     */
cvtsname = Storage(D2x(C2d(cvt)+340),8)     /* get the GRS name       */
ecvtgmod = Storage(D2x(C2d(cvtecvt)+266),1) /* grs mode of operation  */
csdplpn  = Storage(D2x(C2d(cvtcsd)+252),1)  /* PRSM logical partition */
csdplpn  = C2d(csdplpn)                     /*                        */
Select                                      /*                        */
 When (ecvtgmod = x'1') Then ecvtgmod = 'Ring' /*                     */
 When (ecvtgmod = x'2') Then ecvtgmod = 'Star' /*                     */
 Otherwise ecvtgmod = 'None'                   /*                     */
End                                         /*                        */
Return                                      /*                        */
/**********************************************************************/
/* Page dataset information                                           */
/**********************************************************************/
PROC_PAGE:                                  /* Page details         ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtasmvt = Storage(D2x(C2d(cvt)+704),4)     /* get the ASMVT address  */
asmpart  = Storage(D2x(C2d(cvtasmvt)+8),4)  /* Address of PART        */
partsize = Storage(D2x(C2d(asmpart)+4),4)   /* Total entries in PART  */
partdsnl = Storage(D2x(C2d(asmpart)+24),4)  /* Adress of page dsn list*/
page_cnt = 0
Do loop = 0 to C2d(partsize)-1
 parte    = Storage(D2x(C2d(asmpart)+81+(loop*96)),96)
 paretype = X2b(C2x(Substr(parte,8,1)))
 pareflg1 = X2b(C2x(Substr(parte,9,1)))
 If (Substr(pareflg1,1,1) = 1) Then Iterate /* slot not in use        */
 page_cnt = page_cnt + 1
 Select
  When (Substr(paretype,1,1) = '1') Then pagetype = 'PLPA'
  When (Substr(paretype,2,1) = '1') Then pagetype = 'Common'
  When (Substr(paretype,3,1) = '1') Then pagetype = 'Duplex'
  When (Substr(paretype,4,1) = '1') Then pagetype = 'Local'
  Otherwise pagetype = '??????'
 End
 Select
  When (Substr(paretype,7,1) = '1') Then
   pagetype = Left(pagetype,7)||'PageDel'
  When (Substr(paretype,8,1) = '1') Then
   pagetype = Left(pagetype,7)||'Draining'
  Otherwise NOP
 End
 pagedsn  = Storage(D2x(C2d(partdsnl)+(loop*44)),44)
 pareszsl = C2d(Substr(parte,16,4))
 pareslta = C2d(Substr(parte,20,4))
 pareucbp = Substr(parte,44,4)
 ucbchan  = Storage(D2x(C2d(pareucbp)+4),2)
 ucbchan  = C2x(ucbchan)
 ucbvoli  = Storage(D2x(C2d(pareucbp)+28),6)
 pareused = pareszsl - pareslta
 pareused = (pareused/pareszsl)*100
 pagetype = Left(pagetype,16)
 pareused = Right(Format(pareused,3,2)||'%',7)
 pareszsl = Right(pareszsl,7)
 pagedsn  = Left(pagedsn,44)
 ucbchan  = Left(ucbchan,5)
 ucbvoli  = Left(ucbvoli,7)
 text = pagetype||pareused||pareszsl||' '||ucbchan||ucbvoli||pagedsn
 pagelist.page_cnt = text
End
Return                                      /*                        */
/**********************************************************************/
/* Storage information                                                */
/*  additional pointers - thanks to Mark Zelden [mzelden@FLASH.NET]   */
/**********************************************************************/
PROC_STOR:                                  /* storage details      ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtprodi = Storage(D2x(C2d(cvt)-32),8)      /* get the product fmid   */
cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */
cvtgda   = Storage(D2x(C2d(cvt)+560),4)     /* get the GDA  address   */
cvtrcep  = Storage(D2x(C2d(cvt)+1168),4)    /* get the RCE address    */
cvtsmext = Storage(D2x(C2d(cvt)+1196),4)    /* get the OS/VS2 Extensn */
ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address */
ipaarchl = Storage(D2x(C2d(ecvtipa)+2143),1)/* get the architecture lv*/
psaold   = Storage(224,4)                   /* get the ASCB address   */
ascblda  = Storage(D2x(C2d(psaold)+48),4)   /* get the LDA address    */

cvtrlstg = Storage(D2x(C2d(cvt)+856),4)     /* get real Storage size  */
cvtrlstg = (C2d(cvtrlstg)/1024)||'M'        /* convert To Mbytes      */

rceespl  = Storage(D2x(C2d(cvtrcep)+160),4) /* get exp Storage frames */
rceespl  = ((C2d(rceespl)*4)/1024)||'M'     /* convert To Mbytes      */

gdacsa   = Storage(D2x(C2d(cvtgda)+108),4)  /* addr of CSA            */
gdacsasz = Storage(D2x(C2d(cvtgda)+112),4)  /* size of CSA            */
gdacsae  = C2d(gdacsa) + C2d(gdacsasz) - 1  /* end  of CSA            */
gdaecsa  = Storage(D2x(C2d(cvtgda)+124),4)  /* addr of ECSA           */
gdaecsas = Storage(D2x(C2d(cvtgda)+128),4)  /* size of ECSA           */
gdaecsae = C2d(gdaecsa) + C2d(gdaecsas) - 1 /* end  of ECSA           */
gdasqa   = Storage(D2x(C2d(cvtgda)+144),4)  /* addr of SQA            */
gdasqasz = Storage(D2x(C2d(cvtgda)+148),4)  /* size of SQA            */
gdasqae  = C2d(gdasqa) + C2d(gdasqasz) - 1  /* end  of SQA            */
gdaesqa  = Storage(D2x(C2d(cvtgda)+152),4)  /* addr of ESQA           */
gdaesqas = Storage(D2x(C2d(cvtgda)+156),4)  /* size of ESQA           */
gdaesqae = C2d(gdaesqa) + C2d(gdaesqas) - 1 /* end  of ESQA           */
gdapvt   = Storage(D2x(C2d(cvtgda)+160),4)  /* addr of PRIVATE        */
gdapvtsz = Storage(D2x(C2d(cvtgda)+164),4)  /* size of PRIVATE        */
gdaepvt  = Storage(D2x(C2d(cvtgda)+168),4)  /* addr of extended PRIV  */
gdaepvts = Storage(D2x(C2d(cvtgda)+172),4)  /* size of extended PRIV  */
gdaepvte = C2d(gdaepvt) + C2d(gdaepvts) - 1 /* end  of extended PRIV  */
gdavr    = Storage(D2x(C2d(cvtgda)+192),4)  /* addr of global V=R     */
gdavrsz  = Storage(D2x(C2d(cvtgda)+196),4)  /* size of global V=R     */
gdavre   = C2d(gdavr) + C2d(gdavrsz) - 1    /* end  of global V=R     */

cvtmlpas = Storage(D2x(C2d(cvtsmext)+8),4)  /* addr of MLPA           */
cvtmlpae = Storage(D2x(C2d(cvtsmext)+12),4) /* end  of MLPA           */
cvtmlpa  = C2d(cvtmlpae) - C2d(cvtmlpas)    /* size of MLPA           */
cvtflpas = Storage(D2x(C2d(cvtsmext)+16),4) /* addr of FLPA           */
cvtflpae = Storage(D2x(C2d(cvtsmext)+20),4) /* end  of FLPA           */
cvtflpa  = C2d(cvtflpae) - C2d(cvtflpas)    /* size of FLPA           */
cvtplpas = Storage(D2x(C2d(cvtsmext)+24),4) /* addr of PLPA           */
cvtplpae = Storage(D2x(C2d(cvtsmext)+28),4) /* end  of PLPA           */
cvtplpa  = C2d(cvtplpae) - C2d(cvtplpas)    /* size of PLPA           */
cvtrwns  = Storage(D2x(C2d(cvtsmext)+32),4) /* addr of RW Nucleus     */
cvtrwne  = Storage(D2x(C2d(cvtsmext)+36),4) /* end  of RW Nucleus     */
cvtrwn   = C2d(cvtrwne) - C2d(cvtrwns)      /* size of RW Nucleus     */
cvtrons  = Storage(D2x(C2d(cvtsmext)+40),4) /* addr of RO Nucleus     */
cvtrone  = Storage(D2x(C2d(cvtsmext)+44),4) /* end  of RO Nucleus     */
rons_b_e = Right('FFFFFF',8,'0')            /* 16M line 'below'       */
rons_a_s = Right('1000000',8,'0')           /* 16M line 'above'       */
cvtron_b = X2d(rons_b_e) - C2d(cvtrons)     /* size of RO Nucleus <16M*/
cvtron_a = C2d(cvtrone) - X2d(rons_a_s)     /* size of RO Nucleus >16M*/
cvtron   = C2d(cvtrone) - C2d(cvtrons)      /* size of RO Nucleus All */
cvterwns = Storage(D2x(C2d(cvtsmext)+48),4) /* addr of E-RW Nucleus   */
cvterwne = Storage(D2x(C2d(cvtsmext)+52),4) /* end  of E-RW Nucleus   */
cvterwn  = C2d(cvterwne) - C2d(cvterwns)    /* size of E-RW Nucleus   */
cvteplps = Storage(D2x(C2d(cvtsmext)+56),4) /* addr of E-PLPA         */
cvteplpe = Storage(D2x(C2d(cvtsmext)+60),4) /* end  of E-PLPA         */
cvteplp  = C2d(cvteplpe) - C2d(cvteplps)    /* size of E-PLPA         */
cvteflps = Storage(D2x(C2d(cvtsmext)+64),4) /* addr of E-FLPA         */
cvteflpe = Storage(D2x(C2d(cvtsmext)+68),4) /* end  of E-FLPA         */
cvteflp  = C2d(cvteflpe) - C2d(cvteflps)    /* size of E-FLPA         */
cvtemlps = Storage(D2x(C2d(cvtsmext)+72),4) /* addr of E-MLPA         */
cvtemlpe = Storage(D2x(C2d(cvtsmext)+76),4) /* end  of E-MLPA         */
cvtemlp  = C2d(cvtemlpe) - C2d(cvtemlps)    /* size of E-MLPA         */

ldastrta = Storage(D2x(C2d(ascblda)+60),4)  /* addr of addr space     */
ldasiza  = Storage(D2x(C2d(ascblda)+64),4)  /* size of addr space     */
ldastrtz = C2d(ldastrta) + C2d(ldasiza) - 1 /* end  of system region  */
ldastrts = Storage(D2x(C2d(ascblda)+92),4)  /* addr of system region  */
ldasizs  = Storage(D2x(C2d(ascblda)+96),4)  /* size of system region  */
ldastrte = C2d(ldastrts) + C2d(ldasizs) - 1 /* end  of system region  */
ldaregrq = Storage(D2x(C2d(ascblda)+204),4) /* region size requested  */
ldalimit = Storage(D2x(C2d(ascblda)+208),4) /* <16M V=V region limit  */
ldaelim  = Storage(D2x(C2d(ascblda)+216),4) /* >16M V=V region limit  */
ldaloal  = Storage(D2x(C2d(ascblda)+232),4) /* <16M user region alloc */
ldaeloal = Storage(D2x(C2d(ascblda)+240),4) /* >16M user region alloc */

gda_csa_alloc  = Storage(D2x(C2d(cvtgda)+432),4) /* used CSA          */
gda_ecsa_alloc = Storage(D2x(C2d(cvtgda)+436),4) /* used ECSA         */
gda_sqa_alloc  = Storage(D2x(C2d(cvtgda)+440),4) /* used SQA          */
gda_esqa_alloc = Storage(D2x(C2d(cvtgda)+444),4) /* used ESQA         */
gda_csa_conv   = Storage(D2x(C2d(cvtgda)+448),4) /* converted CSA     */
gda_ecsa_conv  = Storage(D2x(C2d(cvtgda)+452),4) /* converted ECSA    */

gdacsa   = Right(C2x(gdacsa),8,'0')         /* pad with zeroes        */
gdacsae  = Right(D2x(gdacsae),8,'0')        /* pad with zeroes        */
gdaecsa  = Right(C2x(gdaecsa),8,'0')        /* pad with zeroes        */
gdaecsae = Right(D2x(gdaecsae),8,'0')       /* pad with zeroes        */
gdasqa   = Right(C2x(gdasqa),8,'0')         /* pad with zeroes        */
gdasqae  = Right(D2x(gdasqae),8,'0')        /* pad with zeroes        */
gdaesqa  = Right(C2x(gdaesqa),8,'0')        /* pad with zeroes        */
gdaesqae = Right(D2x(gdaesqae),8,'0')       /* pad with zeroes        */
gdapvt   = Right(C2x(gdapvt),8,'0')         /* pad with zeroes        */
gdaepvt  = Right(C2x(gdaepvt),8,'0')        /* pad with zeroes        */
gdaepvte = Right(D2x(gdaepvte),8,'0')       /* pad with zeroes        */
gdavr    = Right(C2x(gdavr),8,'0')          /* pad with zeroes        */
gdavre   = Right(D2x(gdavre),8,'0')         /* pad with zeroes        */

gdacsasz = (C2d(gdacsasz)/1024)||'K'        /* convert To kbytes      */
gdaecsas = (C2d(gdaecsas)/1024)||'K'        /* convert To kbytes      */
gdasqasz = (C2d(gdasqasz)/1024)||'K'        /* convert To kbytes      */
gdaesqas = (C2d(gdaesqas)/1024)||'K'        /* convert To kbytes      */
gdapvtsz = (C2d(gdapvtsz)/1024)||'K'        /* convert To kbytes      */
gdaepvts = (C2d(gdaepvts)/(1024*1024))||'M' /* convert To mbytes      */
gdavrsz  = (C2d(gdavrsz)/1024)||'K'         /* convert To kbytes      */

cvtmlpas = Right(C2x(cvtmlpas),8,'0')       /* pad with zeroes        */
cvtmlpae = Right(C2x(cvtmlpae),8,'0')       /* pad with zeroes        */
cvtflpas = Right(C2x(cvtflpas),8,'0')       /* pad with zeroes        */
cvtflpae = Right(C2x(cvtflpae),8,'0')       /* pad with zeroes        */
cvtplpas = Right(C2x(cvtplpas),8,'0')       /* pad with zeroes        */
cvtplpae = Right(C2x(cvtplpae),8,'0')       /* pad with zeroes        */
cvtrwns  = Right(C2x(cvtrwns),8,'0')        /* pad with zeroes        */
cvtrwne  = Right(C2x(cvtrwne),8,'0')        /* pad with zeroes        */
cvtrons  = Right(C2x(cvtrons),8,'0')        /* pad with zeroes        */
cvtrone  = Right(C2x(cvtrone),8,'0')        /* pad with zeroes        */
cvterwns = Right(C2x(cvterwns),8,'0')       /* pad with zeroes        */
cvterwne = Right(C2x(cvterwne),8,'0')       /* pad with zeroes        */
cvteplps = Right(C2x(cvteplps),8,'0')       /* pad with zeroes        */
cvteplpe = Right(C2x(cvteplpe),8,'0')       /* pad with zeroes        */
cvteflps = Right(C2x(cvteflps),8,'0')       /* pad with zeroes        */
cvteflpe = Right(C2x(cvteflpe),8,'0')       /* pad with zeroes        */
cvtemlps = Right(C2x(cvtemlps),8,'0')       /* pad with zeroes        */
cvtemlpe = Right(C2x(cvtemlpe),8,'0')       /* pad with zeroes        */

cvtmlpa  = Format(cvtmlpa/1024,,0)||'K'     /* convert to kbytes      */
cvtflpa  = Format(cvtflpa/1024,,0)||'K'     /* convert to kbytes      */
cvtplpa  = Format(cvtplpa/1024,,0)||'K'     /* convert to kbytes      */
cvtrwn   = Format(cvtrwn/1024,,0)||'K'      /* convert to kbytes      */
cvtron_b = Format(cvtron_b/1024,,0)||'K'    /* convert to kbytes      */
cvtron_a = Format(cvtron_a/1024,,0)||'K'    /* convert to kbytes      */
cvtron   = Format(cvtron/1024,,0)||'K'      /* convert to kbytes      */
cvterwn  = Format(cvterwn/1024,,0)||'K'     /* convert to kbytes      */
cvteplp  = Format(cvteplp/1024,,0)||'K'     /* convert to kbytes      */
cvteflp  = Format(cvteflp/1024,,0)||'K'     /* convert to kbytes      */
cvtemlp  = Format(cvtemlp/1024,,0)||'K'     /* convert to kbytes      */

ldastrta = Right(C2x(ldastrta),8,'0')       /* pad with zeroes        */
ldastrtz = Right(D2x(ldastrtz),8,'0')       /* pad with zeroes        */
ldastrts = Right(C2x(ldastrts),8,'0')       /* pad with zeroes        */
ldastrte = Right(D2x(ldastrte),8,'0')       /* pad with zeroes        */

ldasiza  = Format((C2d(ldasiza)/1024),,0)||'K' /* convert to kbytes   */
ldasizs  = Format((C2d(ldasizs)/1024),,0)||'K' /* convert to kbytes   */
ldaregrq = Format((C2d(ldaregrq)/1024),,0)||'K'/* convert to kbytes   */
ldalimit = Format((C2d(ldalimit)/1024),,0)||'K'/* convert to kbytes   */
ldaelim  = Format((C2d(ldaelim)/1024),,0)||'K' /* convert to kbytes   */
ldaloal  = Format((C2d(ldaloal)/1024),,0)||'K' /* convert to kbytes   */
ldaeloal = Format((C2d(ldaeloal)/1024),,0)||'K'/* convert to kbytes   */

gda_csa_alloc  = Format((C2d(gda_csa_alloc)/1024),,0)||'K'
gda_ecsa_alloc = Format((C2d(gda_ecsa_alloc)/1024),,0)||'K'
gda_sqa_alloc  = Format((C2d(gda_sqa_alloc)/1024),,0)||'K'
gda_esqa_alloc = Format((C2d(gda_esqa_alloc)/1024),,0)||'K'
gda_csa_conv   = Format((C2d(gda_csa_conv)/1024),,0)||'K'
gda_ecsa_conv  = Format((C2d(gda_ecsa_conv)/1024),,0)||'K'

If (ipaarchl = 2) Then
 stor_psa     = Left('00000000',9)||Left('00001FFF',9)||Right('8K',8)
Else
 stor_psa     = Left('00000000',9)||Left('00000FFF',9)||Right('4K',8)
stor_system  = Left(ldastrts,9)||Left(ldastrte,9)||Right(ldasizs,8)
stor_priv_vr = Left(gdavr,9)||Left(gdavre,9)||Right(gdavrsz,8)
stor_priv_vv = Left(ldastrta,9)||Left(ldastrtz,9)||Right(ldasiza,8)
stor_csa     = Left(gdacsa,9)||Left(gdacsae,9)||Right(gdacsasz,8)
stor_csa     = stor_csa||Right(gda_csa_alloc,8)||Right(gda_csa_conv,8)
stor_mlpa    = Left(cvtmlpas,9)||Left(cvtmlpae,9)||Right(cvtmlpa,8)
stor_flpa    = Left(cvtflpas,9)||Left(cvtflpae,9)||Right(cvtflpa,8)
stor_plpa    = Left(cvtplpas,9)||Left(cvtplpae,9)||Right(cvtplpa,8)
stor_sqa     = Left(gdasqa,9)||Left(gdasqae,9)||Right(gdasqasz,8)
stor_sqa     = stor_sqa||Right(gda_sqa_alloc,8)
stor_nuc_rw  = Left(cvtrwns,9)||Left(cvtrwne,9)||Right(cvtrwn,8)
stor_nuc_ro  = Left(cvtrons,9)||Left(rons_b_e,9)||Right(cvtron_b,8)
stor_nuc_ro  = stor_nuc_ro||' (Crosses 16M line)'
stor_nuc_ero = Left(rons_a_s,9)||Left(cvtrone,9)||Right(cvtron_a,8)
stor_nuc_ero = stor_nuc_ero||' (Total '||cvtron||')'
stor_nuc_erw = Left(cvterwns,9)||Left(cvterwne,9)||Right(cvterwn,8)
stor_e_sqa   = Left(gdaesqa,9)||Left(gdaesqae,9)||Right(gdaesqas,8)
stor_e_sqa   = stor_e_sqa||Right(gda_esqa_alloc,8)
stor_e_plpa  = Left(cvteplps,9)||Left(cvteplpe,9)||Right(cvteplp,8)
stor_e_flpa  = Left(cvteflps,9)||Left(cvteflpe,9)||Right(cvteflp,8)
stor_e_mlpa  = Left(cvtemlps,9)||Left(cvtemlpe,9)||Right(cvtemlp,8)
stor_e_csa   = Left(gdaecsa,9)||Left(gdaecsae,9)||Right(gdaecsas,8)
stor_e_csa   = stor_e_csa||Right(gda_ecsa_alloc,8)
stor_e_csa   = stor_e_csa||Right(gda_ecsa_conv,8)
stor_e_priv  = Left(gdaepvt,9)||Left(gdaepvte,9)||Right(gdaepvts,8)
Return                                      /*                        */
/*********************************************************************/
/* Symbol extraction thanks to Mark Zelden [mzelden@FLASH.NET]       */
/*********************************************************************/
PROC_SYMBOL:                                /* static symbols       ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtprodi = Storage(D2x(C2d(cvt)-32),8)      /* get the product fmid   */
cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */
If (Substr(cvtprodi,4,4) >= 5520) Then
 Do
  ecvtsymt = Storage(D2x(c2d(cvtecvt)+296),4) /* get addr of SYMT     */
  symbtnumberofsymbols = Storage(D2x(c2d(ecvtsymt)+2),2)
  Do loop = 1 to C2d(symbtnumberofsymbols)
   offset = (loop-1)*16
   symbtesymboloffset  = Storage(D2x(C2d(ecvtsymt)+4+offset),4)
   symbtesymbollength  = Storage(D2x(c2d(ecvtsymt)+8+offset),4)
   symbtesubtextoffset = Storage(D2x(C2d(ecvtsymt)+12+offset),4)
   symbtesubtextlength = Storage(D2x(c2d(ecvtsymt)+16+offset),4)
   name_o = C2d(symbtesymboloffset)
   name_l = C2d(symbtesymbollength)
   value_o = C2d(symbtesubtextoffset)
   value_l = C2d(symbtesubtextlength)
   sym_nam.loop = Storage(D2x(C2d(ecvtsymt)+4+name_o),name_l)
   sym_val.loop = Storage(D2x(C2d(ecvtsymt)+4+value_o),value_l)
  End
 End
Return                                      /*                        */
/**********************************************************************/
/* JES information                                                    */
/**********************************************************************/
PROC_JES:                                   /* JES details          ##*/
/* 'Old' version */
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */
mvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */
cvtjesct = Storage(D2x(C2d(cvt)+296),4)     /* get the JESCT address  */
jesssct  = Storage(D2x(C2d(cvtjesct)+24),4) /* get jesssct (sscvt)    */
ssctsnam = Storage(D2x(C2d(jesssct)+8),4)   /* get sub-system name    */
ssctsus2 = Storage(D2x(C2d(jesssct)+28),4)  /* point To $hcct         */
Select                                      /*                        */
 When (Substr(mvsfmid,4,4) = 7703) Then     /* OS/390 R10 HBB7703     */
  Do                                        /*                        */
   cctcomch = Storage(D2x(C2d(ssctsus2)+306),1)/* jes command char    */
   cctssnm  = Storage(D2x(C2d(ssctsus2)+616),4)/* jes name of subsys  */
  End                                       /*                        */
 When (Substr(mvsfmid,4,4) = 7713) |,       /* Z/OS R1    JBB7713     */
      (Substr(mvsfmid,4,4) = 7705) |,       /* Z/OS R2    HBB7705     */
      (Substr(mvsfmid,4,4) = 7706) Then     /* Z/OS R3    HBB7706     */
  Do                                        /*                        */
   cctcomch = Storage(D2x(C2d(ssctsus2)+306),1)/* jes command char    */
   cctssnm  = Storage(D2x(C2d(ssctsus2)+776),4)/* jes name of subsys  */
  End                                       /*                        */
 When (Substr(mvsfmid,4,4) >= 7707) Then    /* Z/OS R4    HBB7707     */
  Do                                        /*                        */
   cctcomch = Storage(D2x(C2d(ssctsus2)+386),1)/* jes command char    */
   cctssnm  = Storage(D2x(C2d(ssctsus2)+856),4)/* jes name of subsys  */
  End                                       /*                        */
 Otherwise                                  /* set for R8 and prior   */
  Do                                        /*                        */
   cctcomch = Storage(D2x(C2d(ssctsus2)+242),1)/* jes command char    */
   cctssnm  = Storage(D2x(C2d(ssctsus2)+696),4)/* jes name of subsys  */
  End                                       /*                        */
End                                         /*                        */
                                            /* MVS/ESA SP5.2.2 JBB5522*/
                                            /* OS/390 R1  HBB6601     */
                                            /* OS/390 R2  JBB6602     */
                                            /* OS/390 R3  HBB6603     */
                                            /* OS/390 R4  JBB6604     */
                                            /* OS/390 R5  HBB6605     */
                                            /* OS/390 R6  HBB6606     */
                                            /* OS/390 R7  JBB6607     */
/* get JES node and version                                           */
cctndenm = Sysvar('sysnode')                /* get the JES node name  */
jesname  = Word(Sysvar('sysjes'),1)         /* get the JES system name*/
cctssvs  = Sysvar('sysjes')                 /* get the JES ver-lev-mod*/
Return                                      /*                        */
/**********************************************************************/
/* cpu information                                                    */
/**********************************************************************/
PROC_CPU:                                   /* CPU details          ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtpccat = Storage(D2x(C2d(cvt)+764),4)     /* get the PCCAVT address */
offset = 0                                  /*                        */
cpucnt = 0                                  /*                        */
Do loop = 0 To 15                           /*                        */
 pcca = Storage(D2x(C2d(cvtpccat)+offset),4)/*                        */
 If (D2x(C2d(pcca)) /= 0) Then              /*                        */
  Do                                        /*                        */
   cpucnt = cpucnt + 1                      /*                        */
   cpu.cpucnt = Storage(D2x(C2d(pcca)+4),12)/*                        */
   ser.cpucnt = Substr(cpu.cpucnt,3,6)      /*                        */
   mod.cpucnt = Substr(cpu.cpucnt,9,4)      /*                        */
  End                                       /*                        */
 offset = offset + 4                        /*                        */
End                                         /*                        */
cpumod   = mod.1                            /* get cpu serial model   */
Return                                      /*                        */
/**********************************************************************/
/* cpu information                                                    */
/**********************************************************************/
PROC_HSA:                                   /* HSA details          ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtscpin = Storage(D2x(C2d(cvt)+832),4)     /* get the SCCB address   */
sccbsar  = Storage(D2x(c2d(cvtscpin)+8),2)  /* real stor addr range   */
sccbsai  = Storage(D2x(c2d(cvtscpin)+10),1) /* real stor addr incrmnt */
sccbsbs  = Storage(D2x(c2d(cvtscpin)+11),1) /* real stor addr blksize */
sccbncps = Storage(D2x(c2d(cvtscpin)+16),2) /* installed CPU count    */
sccbnhsa = Storage(D2x(c2d(cvtscpin)+20),2) /* number of HSAs         */
sccbohsa = Storage(D2x(c2d(cvtscpin)+22),2) /* HSA offset from SCCB   */
sccbparm = Storage(D2x(c2d(cvtscpin)+24),8) /* load parm              */
sccbmesi = Storage(D2x(c2d(cvtscpin)+32),4) /* ext  stor addr range   */
sccbnxsb = Storage(D2x(c2d(cvtscpin)+36),4) /* ext  stor addr blocks  */
sccbrcci = Storage(D2x(c2d(cvtscpin)+86),4) /* capacity               */
stor_rel = C2d(sccbsar)*C2d(sccbsai)
stor_ext = (C2d(sccbmesi)*((C2d(sccbnxsb)*4)))/1024
hsaaddr  = D2c(C2d(cvtscpin)+C2d(sccbohsa))
Do loop = 1 to C2d(sccbnhsa)
 offset = C2d(sccbohsa)+((loop*6)-6)
 sccbhssz = Storage(D2x(C2d(cvtscpin)+C2d(sccbohsa)+((loop*6)-6)),2)
 sccbahsa = Storage(D2x(C2d(cvtscpin)+C2d(sccbohsa)+((loop*6)-6)+2),4)
 hsa_size = (C2d(sccbhssz)*4)/1024
 hsa_size.loop = hsa_size
End
Return                                      /*                        */
/**********************************************************************/
/* version information                                                */
/**********************************************************************/
PROC_VERSION:                               /* version details      ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtrac   = Storage(D2x(C2d(cvt)+992),4)     /* get the RCVT address   */
rcvtvrmn = Storage(D2x(C2d(cvtrac)+616),4)  /* get the RACF version   */
rcvtfmid = 'HRF'||rcvtvrmn                  /* create FMID name       */
ra = rcvtvrmn
rcvtvrmn = Substr(ra,1,1)'.'Substr(ra,2,1)'.'Substr(ra,3,2)
cvtjesct = Storage(D2x(C2d(cvt)+296),4)     /* get the JESCT address  */
jesssct  = Storage(D2x(C2d(cvtjesct)+24),4) /* get jesssct (sscvt)    */
ssctsus2 = Storage(D2x(C2d(jesssct)+28),4)  /* point To $hcct         */
cctssvs  = Storage(D2x(C2d(ssctsus2)+700),4)/* jes version-level-mod  */
cc = cctssvs
cctssvs  = Substr(cc,2,1)'.'Substr(cc,3,1)'.'Substr(cc,4,1)
cvttvt   = Storage(D2x(C2d(cvt)+156),4)     /* get the TSO VT address */
tsvttsol = Storage(D2x(C2d(cvttvt)+100),4)  /* get the TSO version    */
ts = tsvttsol
tsvttsol = Substr(ts,1,1)'.'Substr(ts,2,2)'.'Substr(ts,4,1)
cvtdfa   = Storage(D2x(C2d(cvt)+1216),4)    /* get the DFP ID table   */
cvtdfa   = Storage(D2x(C2d(cvt)+1216),4)    /* get the DFP ID table   */
dfaprod  = Storage(D2x(C2d(cvtdfa)+16),1)   /* get the release byte   */
If (dfaprod = 0) Then                       /* DFP                    */
 Do                                         /*                        */
  df     = Substr(C2x(Storage(D2x(C2d(cvtdfa)+2),2)),1,3)       /*    */
  dfarel = Substr(df,1,1)'.'Substr(df,2,1)'.'Substr(df,3,1)
  dfaprd = 'DFP'                            /*                        */
 End                                        /*                        */
Else                                        /* DFSMS                  */
 Do                                         /*                        */
  df     = Substr(C2x(Storage(D2x(C2d(cvtdfa)+16),4)),3,6)      /*    */
  dfarel = Substr(df,1,2)'.'Substr(df,3,2)'.'Substr(df,5,2)
  dfaprd = 'DFSMS'                          /*                        */
 End                                        /*                        */
cvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */
cvtatcvt = Storage(D2x(C2d(cvtext2)+65),3)  /* get the VTAM AVT       */
istatcvt = Storage(D2x(C2d(cvtatcvt)+0),4)  /* get the VTAM CVT       */
atcvtlvl = Storage(D2x(C2d(istatcvt)+0),8)  /* get the VTAM version   */
vt = atcvtlvl
vtamvers = Substr(vt,3,1)'.'Substr(vt,4,1)'.'Substr(vt,5,1)
Return                                      /*                        */
/**********************************************************************/
/* Get TCP/IP information - Ken Smith [kenneth.smith@VERIZON.COM]     */
/*                          at Mon 08/10/2001 7:58 PM                 */
/*                          on MVS-OE@VM.MARIST.EDU                   */
/**********************************************************************/
PROC_TCPIP:                                 /* TCPIP details        ##*/
vers      = Socket('version')
init      = Socket('initialise','LEVELSYS')
parse var init init_rc subtaskid maxdesc service
hostid    = Socket('GETHOSTID')
hostname  = Socket('GETHOSTNAME')
domain    = Socket('GETDOMAINNAME')
portidt   = Socket('GETSERVBYNAME','TELNET','TCP')
portidf   = Socket('GETSERVBYNAME','FTP','TCP')
term      = Socket('terminate')
/* parse  ======>  ==========> ======>  */
parse var hostid   return_code tcpaddr
parse var hostname return_code tcpname
parse var domain   return_code tcpdom
parse var portidt  return_code tcp telport telnet
parse var portidf  return_code tcp ftpport telnet
Return                                      /*                        */
/**********************************************************************/
/* Get OMVS details                                                   */
/**********************************************************************/
PROC_OMVS:                                  /* OMVS details         ##*/
omvs = syscalls('ON')                       /*                        */
If (omvs = 0) Then                          /*                        */
 Do                                         /*                        */
  Address SYSCALL "getpwnam "Userid()" pw." /* get user details       */
  pw_dir   = pw.pw_dir                      /*                        */
  pw_gid   = pw.pw_gid                      /*                        */
  pw_name  = pw.pw_name                     /*                        */
  pw_shell = pw.pw_shell                    /*                        */
  pw_uid   = pw.pw_uid                      /*                        */
  Address SYSCALL "getmntent mt."           /* get mount details      */
  mount_cnt = mt.0                          /*                        */
  Do loop = 1 to mount_cnt                  /*                        */
   mt.loop = mt.mnte_fsname.loop mt.mnte_fstype.loop mt.mnte_dev.loop
  End                                       /*                        */
 End                                        /*                        */
x = syscalls('OFF')                         /*                        */
Return                                      /*                        */
/**********************************************************************/
/* get service unit / performance details                             */
/**********************************************************************/
/* Based on code on MXG-L : 13/07/2000                                */
/* from - Edward(Ed) J. Finnell, III [efinnell@seebeck.ua.edu]        */
/**********************************************************************/
PROC_PERFORM:                               /* performance details  ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtopctp = Storage(D2x(C2d(cvt)+604),4)     /* get the RMCT address   */
cvtpccat = Storage(D2x(C2d(cvt)+764),4)     /* get the PCCAVT address */
rmctadjc = Storage(D2x(C2d(cvtopctp)+64),4) /* get CPU RATE ADJUSTMENT*/
offset = 0                                  /*                        */
cpucnt = 0                                  /*                        */
Do loop = 0 To 15                           /*                        */
 pcca = Storage(D2x(C2d(cvtpccat)+offset),4)/*                        */
 If (D2x(C2d(pcca)) /= 0) Then              /*                        */
  cpucnt = cpucnt + 1                       /*                        */
 offset = offset + 4                        /*                        */
End                                         /*                        */
su       = 16000000/C2d(rmctadjc)           /* adjust for SUs         */
unimips  = su/48.5                          /* calc for MIPS          */
mips     = unimips * cpucnt                 /*                        */
msu      = su*cpucnt*3600/1000000           /*                        */
su       = Format(su,,2)                    /*                        */
unimips  = Format(unimips,,2)               /*                        */
mips     = Format(mips,,2)                  /*                        */
msu      = format(msu,,0)                   /*                        */
Return                                      /*                        */
/**********************************************************************/
/* Get sub-system prefix details - CPFT details from SHOWMVS          */
/**********************************************************************/
PROC_SUBSYS_PREFIX:                         /* subsystem prefixes   ##*/
cvt      = Storage(10,4)                    /* get the CVT address    */
cvtcucb  = Storage(D2x(C2d(cvt)+100),4)     /* get the UCM address    */
ucmbfext = Storage(D2x(C2d(cvtcucb)+240),4) /* get UCM Base extension */
ucmcpfta = Storage(D2x(C2d(ucmbfext)+176),4)/* get the CPFT address   */
cpftacro = Storage(D2x(C2d(ucmcpfta)+0),4)  /* Get the CPFT eyecatcher*/
cpftvrsn = Storage(D2x(C2d(ucmcpfta)+4),1)  /* Get the CPFT version   */
cpftnume = Storage(D2x(C2d(ucmcpfta)+8),4)  /* Get the CPFT entry cnt */
cpft1st  = Storage(D2x(C2d(ucmcpfta)+12),4) /* Get CPFT 1st entry off */
cpftlast = Storage(D2x(C2d(ucmcpfta)+16),4) /* Get CPFT last entry off*/
cpftent  = D2c(C2d(ucmcpfta)+C2d(cpft1st))  /* get entry address      */
Do loop = 1 to C2d(cpftnume)                /* loop thru CPFT         */
 cpftflgs = Storage(D2x(C2d(cpftent)+0),1)  /* get the flags          */
 cpftflgs = X2b(C2x(cpftflgs))
 If (Substr(cpftflgs,1,1) = '1') Then cpftscop = 'Sysplex '
                                 Else cpftscop = 'System  '
 If (Substr(cpftflgs,3,1) = '1') Then cpftfdp1 = 'Syspurge'
                                 Else cpftfdp1 = 'Purge   '
 If (Substr(cpftflgs,4,1) = '1') Then cpftremv = 'Yes     '
                                 Else cpftremv = 'No      '
 cpftprfx = Storage(D2x(C2d(cpftent)+4),8)  /* get the prefix         */
 cpftprln = Storage(D2x(C2d(cpftent)+12),1) /* get the prefix length  */
 cpftownr = Storage(D2x(C2d(cpftent)+16),8) /* get the owner          */
 cpftsys  = Storage(D2x(C2d(cpftent)+24),8) /* get the system         */
 cpftasid = Storage(D2x(C2d(cpftent)+28),4) /* get the ASID           */
 cpftent  = D2c(C2d(cpftent)+44)            /* set for next entry     */
 cpft.loop = cpftprfx cpftownr cpftsys cpftscop cpftremv cpftfdp1
End                                         /*                        */
Return                                      /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva=C2d(Arg(1))                             /* convert to decimal     */
tcb = C2d(Storage(21C,4))                   /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/
DEFINE_PANEL:                               /* Create display panel   */
X01 = '01'X                                 /* set hex '01' variable  */
X02 = '02'X                                 /* set hex '02' variable  */
X03 = '03'X                                 /* set hex '03' variable  */
X05 = '05'X                                 /* set hex '05' variable  */
X09 = '09'X                                 /* set hex '09' variable  */
X0A = '0A'X                                 /* set hex '0A' variable  */
X0B = '0B'X                                 /* set hex '0B' variable  */
X16 = '16'X                                 /* set hex '16' variable  */
X19 = '19'X                                 /* set hex '19' variable  */
X22 = '22'X                                 /* set hex '22' variable  */
X08 = '08'X                                 /* set hex '08' variable  */
X26 = '26'X                                 /* set hex '26' variable  */
X27 = '27'X                                 /* set hex '27' variable  */
"NewStack"                                  /* Create new stack       */
member = 'SYSINFO'                          /* set panel name         */
Queue ")PANEL KEYLIST(ISRSNAB,ISR)"
Queue ")ATTR DEFAULT("X01||X02||X03") FORMAT(MIX)"
Queue " 05 TYPE(PT)"
Queue " 09 TYPE(FP)"
Queue " 0A TYPE(NT)"
Queue " 16 TYPE(VOI) PADC(USER)"
Queue " 19 TYPE(DT)"
Queue " 22 TYPE(WASL) SKIP(ON)"
Queue " 08 TYPE(CH)"
Queue " 0B TYPE(ET)"
Queue " 26 TYPE(NEF) CAPS(ON) PADC(USER)"
Queue " 27 AREA(SCRL) EXTEND(ON)"
Queue ")BODY  CMD(ZCMD)"
Queue X0A||Centre(X05||"System Information"||X0A,78)||X0A
Queue X09||"Command ===>"||X26||Left("ZCMD",65)||X0A
Queue X27||Left("SAREA39",78)||X27
Queue X27||Left("",78)||X27
Queue ")AREA SAREA39"
Queue " User Information"
Queue " "X09"Your RACF user-id . . :"X0B||Left(Userid()  ,53)||X0A
Queue " "X09"Your RACF name is . . :"X0B||Left(username  ,53)||X0A
Queue " "X09"Your RACF account . . :"X0B||Left(acctnum   ,53)||X0A
Queue " "X09"Your Connect group  . :"X0B||Left(aceegrpn  ,53)||X0A
lead = " "X09"Your RACF groups. . . :"X0B
groups = ''
gl_cnt = 0
Do loop = 1 to grp_cnt
 groups = groups||Left(group.loop,10)
 gl_cnt = gl_cnt + 1
 If (gl_cnt = 5) Then
  Do
   Queue lead||groups
   lead = " "X09"                       "X0B
   groups = ''
   gl_cnt = 0
  End
End
If (gl_cnt > 0) Then
 Queue lead||groups
If (Strip(team) /= '') & (Strip(team) /= 'TEAM') Then
 Queue " "X09"Your logon team . . . :"X16||Left("TEAM    ",53)||X0A
Queue " "X09"Your Terminal ID. . . :"X0B||Left(aceetrid  ,53)||X0A
Queue " "X09"Your job ID . . . . . :"X0B||Left(ssibjbid  ,53)||X0A
Queue " "X09"Your RACF Attributes. :"X0B||Left(racfacc   ,53)||X0A
If (strip(lwalgcmd,B) /= '') Then
 Queue " "X09"Your logon command. . :"X0B||Left(lwalgcmd  ,53)||X0A
Queue " "X09"Your current APPLID . :"X16||Left("ZAPPLID ",53)||X0A
Queue " "X09"Your current PREFIX . :"X16||Left("ZPREFIX ",53)||X0A
Queue " "X09"Screens in use. . . . :"X16||Left("ZSCRCUR ",53)||X0A
Queue " "X09"Maximum screens . . . :"X16||Left("ZSCRMAX ",53)||X0A
Queue " "X09"Region Size . . . . . :"X0B||Left(region    ,53)||X0A
If (omvs = 0) Then
 Do
  Queue " "X09"OMVS Initial Work Dir :"X0B||Left(pw_dir    ,53)||X0A
  Queue " "X09"OMVS Group ID . . . . :"X0B||Left(pw_gid    ,53)||X0A
  Queue " "X09"OMVS Shell. . . . . . :"X0B||Left(pw_shell  ,53)||X0A
  Queue " "X09"OMVS UID. . . . . . . :"X0B||Left(pw_uid    ,53)||X0A
 End
Queue " "
Queue " System Information"
Queue " "X09"System ID . . . . . . :"X16||Left("ZSYSID  ",53)||X0A
Queue " "X09"SMF ID. . . . . . . . :"X0B||Left(smcasid   ,53)||X0A
Queue " "X09"GRS Name. . . . . . . :"X0B||Left(cvtsname  ,53)||X0A
Queue " "X09"GRS Mode. . . . . . . :"X0B||Left(ecvtgmod  ,53)||X0A
Queue " "X09"Sysplex Identifier. . :"X0B||Left(ecvtclon  ,53)||X0A
Queue " "X09"Sysplex Name  . . . . :"X0B||Left(ecvtsplx  ,53)||X0A
If (Strip(ecvtlpnm) /= '') Then
 Queue " "X09"LPAR name . . . . . . :"X0B||Left(ecvtlpnm  ,53)||X0A
If (Strip(csdplpn) /= '') Then
 Queue " "X09"LPAR number . . . . . :"X0B||Left(csdplpn   ,53)||X0A
If (Strip(ecvthdnm) /= '') Then
 Queue " "X09"Hardware name . . . . :"X0B||Left(ecvthdnm  ,53)||X0A
If (Strip(ecvtvmnm) /= '') Then
 Queue " "X09"VM Host name. . . . . :"X0B||Left(ecvtvmnm  ,53)||X0A
Queue " "X09"Product Owner . . . . :"X0B||Left(ecvtpown  ,53)||X0A
Queue " "X09"Product Name. . . . . :"X0B||Left(ecvtpnam  ,53)||X0A
Queue " "X09"Product Version . . . :"X0B||Left(ecvtpver  ,53)||X0A
Queue " "X09"Product Release . . . :"X0B||Left(ecvtprel  ,53)||X0A
Queue " "X09"Product mod level . . :"X0B||Left(ecvtpmod  ,53)||X0A
Queue " "X09"JES name. . . . . . . :"X0B||Left(cctssnm   ,53)||X0A
Queue " "X09"JES node name . . . . :"X0B||Left(cctndenm  ,53)||X0A
Queue " "X09"JES command character :"X0B||Left(cctcomch  ,53)||X0A
Queue " "X09"RACF. . . . . . . . . :"X0B||Left(racf      ,53)||X0A
curmastc = dsncat||' on '||volcat           /* build for display      */
Queue " "X09"Master Catalog  . . . :"X0B||Left(curmastc  ,53)||X0A
curracfd = dsnrac||' on '||volrac           /* build for display      */
Queue " "X09"RACF Database . . . . :"X0B||Left(curracfd  ,53)||X0A
Queue " "
Queue " Sub-System Information"
Queue " "X09"Prefix   Owner    System   Scope    Remove   Faildisp"
Do loop = 1 to C2d(cpftnume)
 Queue " "X0B||cpft.loop||X0A
End
Queue " "
Queue " Software Information"
Queue "                          Version                  FMID"
text = X09"MVS . . . . . . . . . :"X0B
Queue " "text||Left(mvsver,25)||Left(mvsfmid,8)||X0A
text = X09"RACF  . . . . . . . . :"X0B
Queue " "text||Left(rcvtvrmn,25)||rcvtfmid||X0A
text = X09"JES . . . . . . . . . :"X0B
Queue " "text||Left(cctssvs,25)||X0A
text = X09"ISPF  . . . . . . . . :"X16
Queue " "text||Left("ZISPFOS",25)||X0A
pad = '. . . . . . . . . . . . . . :'
dfaprd = dfaprd||' '
dfa_len  = Length(dfaprd)
text = X09||dfaprd||Right(pad,23-dfa_len)||X0B
Queue " "text||Left(dfarel,25)||X0A
text = X09"TSO . . . . . . . . . :"X0B
Queue " "text||Left(tsvttsol,25)||X0A
text = X09"VTAM  . . . . . . . . :"X0B
Queue " "text||Left(vtamvers,25)||X0A
Queue " "
Queue " TCP/IP Information"
Queue " "X09"Domain name . . . . . :"X0B||Left(tcpdom    ,53)||X0A
Queue " "X09"Host ID . . . . . . . :"X0B||Left(tcpaddr   ,53)||X0A
Queue " "X09"Host Name . . . . . . :"X0B||Left(tcpname   ,53)||X0A
Queue " "X09"Telnet Port-ID  . . . :"X0B||Left(telport   ,53)||X0A
Queue " "X09"FTP Port-ID . . . . . :"X0B||Left(ftpport   ,53)||X0A
Queue " "
Queue " Symbolic Information"
Do loop = 1 to C2d(symbtnumberofsymbols)
 pad = '. . . . . . . . . . . . . . :'
 sym_name = sym_nam.loop||' '
 sym_len  = Length(sym_name)
 sym_name = sym_name||Right(pad,23-sym_len)
 Queue "  "||sym_name||X0B||Left(sym_val.loop,53)||X0A
End
Queue " "
Queue " Storage Information"
Queue " "X09"Real. . . . . . . . . :"X0B||Left(cvtrlstg  ,53)||X0A
buff_rel = stor_rel - Strip(cvtrlstg,T,'M')
If (buff_rel > 0) Then
 Queue " "X09"Buffer (Real) . . . . :"X0B||Left(buff_rel'M',53)||X0A
Queue " "X09"Extended. . . . . . . :"X0B||Left(rceespl   ,53)||X0A
buff_ext = stor_ext - Strip(rceespl,T,'M')
If (buff_ext > 0) Then
 Queue " "X09"Buffer (Extended) . . :"X0B||Left(buff_ext'M',53)||X0A
Queue " "X09"Private < 16M . . . . :"X0B||Left(gdapvtsz  ,53)||X0A
If (C2d(sccbnhsa) > 0) Then
 Do loop =  1 to C2d(sccbnhsa)
  text = " "X09"HSA . . . . . . . . . :"X0B||Right(loop,3)
  text = text||hsa_size.loop||X0A
  Queue text
 End
Queue " "
Queue " User Storage"
Queue " "X09"Region Requested. . . :"X0B||Left(ldaregrq  ,53)||X0A
Queue " "X09"<16M Limit. . . . . . :"X0B||Left(ldalimit  ,53)||X0A
Queue " "X09">16M Limit. . . . . . :"X0B||Left(ldaelim   ,53)||X0A
Queue " "X09"<16M Used . . . . . . :"X0B||Left(ldaloal   ,53)||X0A
Queue " "X09">16M Used . . . . . . :"X0B||Left(ldaeloal  ,53)||X0A
Queue " "
Queue " Virtual Storage Map"
Queue Left(' ',26)||"Start    End          Size    Used Convert"
Queue " "X09"             PSA  . . :"X0B||Left(stor_psa      ,53)||X0A
Queue " "X09"          System  . . :"X0B||Left(stor_system   ,53)||X0A
Queue " "X09"     Private V=R  . . :"X0B||Left(stor_priv_vr  ,53)||X0A
Queue " "X09"     Private V=V  . . :"X0B||Left(stor_priv_vv  ,53)||X0A
Queue " "X09"             CSA  . . :"X0B||Left(stor_csa      ,53)||X0A
Queue " "X09"            MLPA  . . :"X0B||Left(stor_mlpa     ,53)||X0A
Queue " "X09"            FLPA  . . :"X0B||Left(stor_flpa     ,53)||X0A
Queue " "X09"            PLPA  . . :"X0B||Left(stor_plpa     ,53)||X0A
Queue " "X09"             SQA  . . :"X0B||Left(stor_sqa      ,53)||X0A
Queue " "X09"     R/W Nucleus  . . :"X0B||Left(stor_nuc_rw   ,53)||X0A
Queue " "X09"     R/O Nucleus  . . :"X0B||Left(stor_nuc_ro   ,53)||X0A
Queue " "X09"            16M  ---------------------------------"||X0A
Queue " "X09"Ext. R/O Nucleus  . . :"X0B||Left(stor_nuc_ero  ,53)||X0A
Queue " "X09"Ext. R/W Nucleus  . . :"X0B||Left(stor_nuc_erw  ,53)||X0A
Queue " "X09"        Ext. SQA  . . :"X0B||Left(stor_e_sqa    ,53)||X0A
Queue " "X09"       Ext. PLPA  . . :"X0B||Left(stor_e_plpa   ,53)||X0A
Queue " "X09"       Ext. FLPA  . . :"X0B||Left(stor_e_flpa   ,53)||X0A
Queue " "X09"       Ext. MLPA  . . :"X0B||Left(stor_e_mlpa   ,53)||X0A
Queue " "X09"        Ext. CSA  . . :"X0B||Left(stor_e_csa    ,53)||X0A
Queue " "X09"    Ext. Private  . . :"X0B||Left(stor_e_priv   ,53)||X0A
Queue " "
Queue " IPL Information"
Queue " "X09"LOAD Parameter. . . . :"X0B||Left(ipalparm  ,53)||X0A
Queue " "X09"LOAD Parm DSN . . . . :"X0B||Left(ipalpdsn  ,53)||X0A
Queue " "X09"IEASYSxx suffix . . . :"X0B||Left(ipasplst  ,53)||X0A
Queue " "X09"Parmlib/s . . . . . . :"X0B||Left(parmlin.1 ,69)||X0A
If (parm_cnt > 1) Then
 Do loop = 2 to parm_cnt
  Queue " "Right(X0B,25)||Left(parmlin.loop,69)||X0A
 End
Queue " "X09"Last IPL. . . . . . . :"X0B||Left(ipldates  ,53)||X0A
Queue " "X09"Current Date  . . . . :"X0B||Left(curdates  ,53)||X0A
Queue " "X09"Elapsed Since IPL . . :"X0B||Left(offdates  ,53)||X0A
curres   = sysuad||' - '||sysres            /* build for display      */
Queue " "X09"RES Volume. . . . . . :"X0B||Left(curres    ,53)||X0A
Queue " "X09"IO Config . . . . . . :"X0B||Left(cvtiocid  ,53)||X0A
Queue " "X09"IODF Dataset. . . . . :"X0B||Left(iodfname  ,53)||X0A
Queue " "X09"Configuration ID. . . :"X0B||Left(iodfcfgi  ,53)||X0A
Queue " "X09"EDT . . . . . . . . . :"X0B||Left(iodfedt   ,53)||X0A
If (Substr(iodfproc,1,1) <> '00'X) &,
   (Substr(iodfproc,1,1) <> '40'X) Then
 Do
  Queue " "X09"IODF Processor. . . . :"X0B||Left(iodfproc  ,53)||X0A
  iodftext = iodfdate' 'iodftime
  Queue " "X09"IODF Date/Time. . . . :"X0B||Left(iodftext  ,53)||X0A
  Queue " "X09"IODF Description. . . :"X0B||Left(iodfdesc  ,53)||X0A
 End
Queue " "X09"Master JCL. . . . . . :"X0B||Left(mstrjcl   ,53)||X0A
Queue " "
Do loop = 1 to mjcl0
 Queue " "Right(X0B,9)||Left("&mjcl"loop,69)||X0A
End
Queue " "
Queue " Hardware Information - General"
Queue " "X09"CPU Type. . . . . . . :"X0B||Left(type      ,53)||X0A
Queue " "X09"CPU Model . . . . . . :"X0B||Left(model     ,53)||X0A
Queue " "X09"CPU Manufacturer. . . :"X0B||Left(man       ,53)||X0A
Queue " "X09"CPU Plant . . . . . . :"X0B||Left(plant     ,53)||X0A
Queue " "X09"CPU Sequence Number . :"X0B||Left(seqno     ,53)||X0A
Queue " "X09"CPU Serial Model. . . :"X0B||Left(cpumod    ,53)||X0A
Queue " "
Queue " Hardware Information - This complex"
Queue " "X09"CPU Count . . . . . . :"X0B||Left(cpucnt    ,53)||X0A
Queue " "X09"CPU Serials . . . . . :"X0B"#1 "Left(CPU.1     ,50)||X0A
Do loop = 2 to cpucnt
 no = '#'Left(loop,2)
 Queue " "X09"                       "X0B||no||Left(CPU.loop,50)||X0A
End
Queue " "X09||"CPU SU/Sec. . . . . . :"X0B||Left(su        ,53)||X0A
Queue " "X09||"CPU MIPS. . . . . . . :"X0B||Left(mips      ,53)||X0A
Queue " "X09||"CPU MIPS (single) . . :"X0B||Left(unimips   ,53)||X0A
Queue " "X09||"CPU MSU (not Amdahl). :"X0B||Left(msu       ,53)||X0A
Queue " "
Queue " Address Space Information"
Queue " "X09||"Maximum ASIDs . . . . :"X0B||Left(asvtmaxu  ,53)||X0A
Queue " "X09||"Available ASIDs . . . :"X0B||Left(asvtaav   ,53)||X0A
Queue " "X09||"ASIDs in-use. . . . . :"X0B||Left(okcnt     ,53)||X0A
Queue " "X09||"ASIDs non-reusable. . :"X0B||Left(duffcnt   ,53)||X0A
Queue " "X09||"Free Slots SASI queue :"X0B||Left(asvtast   ,53)||X0A
Queue " "X09||"Free Slots NonR queue :"X0B||Left(asvtanr   ,53)||X0A
Queue " "X09||"Orig. size SASI queue :"X0B||Left(asvtstrt  ,53)||X0A
Queue " "X09||"Orig. size NonR queue :"X0B||Left(asvtnonr  ,53)||X0A
Queue " "
Queue " Page Dataset Information"
Queue "  type             used    slots addr volser dsname"
Do loop = 1 to page_cnt
 Queue " "X0B||Left(pagelist.loop,77)||X0A
End
Queue " "
Queue " IEASYSxx Parameter Details"
Queue "  source         parm value"
Do loop = 1 to para_cnt
 If (loop < para_cnt) Then delim = ','
                      Else delim = ' '
 If (parm_nm.loop = 'NONVIO')   |,
    (parm_nm.loop = 'PAGE')     |,
    (parm_nm.loop = 'PAGE-OPR') |,
    (parm_nm.loop = 'SWAP')     Then
  Do
   dsns = Translate(parm.loop,' ',',')
   dsns_cnt = Words(dsns)
   parm_name = parm_nm.loop
   parm_type = parm_ty.loop
   parm_sign= '='
   Do doop = 1 to dsns_cnt
    parm_disp = Right(parm_name,10)||parm_sign||Word(dsns,doop)||","
    Queue "  "||parm_type||X0B||Left(parm_disp,60)||X0A
    parm_name = Left('',10)
    parm_sign = Left('',2)
    parm_type = Left('',8)
   End
  End
 Else
  Do
   parm_disp = Right(parm_nm.loop,10)||'='||parm.loop||delim
   Queue "  "||parm_ty.loop||X0B||Left(parm_disp,60)||X0A
  End
End
Queue " "
Queue X22||X22
Queue ")INIT"
Queue "&ZCMD = ' '"
Queue ")PROC"
Queue ")END"
Return
/**********************************************************************/
CREATE_MEMBER:                              /* Create Member in PDS   */
Do loop = 1 To 50                           /* loop thru up to 50     */
 fil = 'DYNAM'||loop                        /*  build filename        */
 x = Listdsi(fil FILE)                      /*  test filename         */
 If (sysreason > 0) Then                    /*  if not present        */
  Leave                                     /*   use it !             */
End                                         /* end loop               */
Address TSO                                 /* set address            */
"Alloc Fi("fil") ",                         /* Allocate dyamic        */
      "Lrecl(80) Blksize(0) RecFm(F B) ",   /*  dataset to selected   */
      "Cylinders Space(1,1) ",              /*   filename             */
      "Unit(SYSDA) Dir(20) New Reu"         /*                        */
X = Listdsi(fil FILE)                       /* get the file details   */
stack = Queued()                            /*   get stack size       */
If (stack > 0) Then                         /*   if data on stack     */
 Do                                         /*                        */
  "Alloc Fi(MEMOUT) Shr Reu ",              /*    create member       */
        "Da('"sysdsname"("member")')"       /*                        */
  "ExecIO "stack" DiskW MEMOUT (Finis)"     /*    write stack > member*/
  "Free Fi(MEMOUT)"                         /*    free member         */
 End                                        /*                        */
member = Word(line,2)                       /*   get next member name */
"DelStack"                                  /* Clear stack            */
/*
Address ISPEXEC "EDIT DATASET('"SYSDSNAME"') VOLUME("SYSVOLUME")"
*/
Return
